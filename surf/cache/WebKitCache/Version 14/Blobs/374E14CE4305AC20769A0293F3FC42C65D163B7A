// BEGIN: doc.ready
$(document).ready(function ($) {
		
		
		var windowSize = $(window).width();
		
		if (windowSize < 600 ) {
			$('#shopCompareFilter h4').show();
			$('#shopCompareFilter .splashBody').hide();
			$('#shopCompareFilter h4 a.toggle').click(
				function() {$('#shopCompareFilter .splashBody').toggle();}
			);
		}			
		else {
				$('#shopCompareFilter .splashBody').show();
				$('#shopCompareFilter h4').hide();
			}



	// Raty star rating 
	$('.star-rating-container').raty({ 
		readOnly: true,
		numberMax : 5,
		half     : true,
  		starType : 'i',
  		score: function() {
    		return $(this).attr('data-score');
  		},
  		hints: []
	});
	
	// bureau for shop compare filter on category page (accordian functionality)
		$('#shopCompareFilter').bureau({
			showToggleAllButton: true,
			showToggleAllButtonText: 'Open all'
		});

	// show/hide functionality for search at 0-599px range
	   	$('.show_hide').showHide({
	        speed: 1,  // speed you want the toggle to happen
	        easing: '',  // the animation effect you want. Remove this line if you dont want an effect and if you haven't included jQuery UI
	        changeText: 0, // if you dont want the button text to change, set this to 0
	        showText: 'View',// the button text to show when a div is closed
	        hideText: 'Close' // the button text to show when a div is open
	    });
        
	    // scroll to fixed left nav
	    $('.nav-secondary.scroll').scrollToFixed({ 
	    	marginTop: 10,
            dontCheckForPositionFixedSupport: true,
            limit: function() {
                var limit = $('#scrolltofixed_endContainer').offset().top - $('.nav-secondary.scroll').outerHeight(true) - 10;
                return limit;
            }
        });
        
        // initialize Royal Slider - used on Review Summary Tab)	
		$('#gallery-1').royalSlider({
	    fullscreen: {
	      enabled: false,
	      nativeFS: true
	    },
	    controlNavigation: 'thumbnails',
	    autoScaleSlider: true, 
	    autoScaleSliderWidth: 560,     
	    autoScaleSliderHeight: 380,
	    loop: false,
	    numImagesToPreload:4,
	    arrowsNavAutohide: true,
	    arrowsNavHideOnTouch: true,
	    keyboardNavEnabled: true
	  });
	  // initialize Zuper Slider - used on SuperCategory Pages)
	  $(".zuperSlider").zuperSlider({mode:"none",arrows:{next:false,nextHorizontal:"end-71",nextVertical:"end-100",prev:false,prevHorizontal:"end-100",prevVertical:"end-100"},nav:{active:true,type:"numbers",imagesDimension:"105x55",navHorizontal:"end-100",navVertical:225,thumbs:false,thumbsDimension:"120x80"},auto:{active:true,time:4000,timer:"none",hoverStop:true,posHorizontal:30,posVertical:20,playPause:true,playPauseHover:true,playPauseHorizontal:595,playPauseVertical:28},animate:{type:"sliderHorizontal",speed:1000,position:["centerToMarginSquare","horizontal"],effect:["slideAlternativeH","fade"],cols:1,rows:25,delay:10,easing:"linear",car_nr:7,perPage:1},multipleEff:{active:false,random:false,eff:[]},order:{random:false,startSlide:1,firstSlide:1},caption:true,touchNavigation:true,bgImageScaleAndCenter:true,responsive:true,navigateOnHover:false,navigateWithMouseWheel:false})

	//search box scripts
	$("#headerSearchTextbox, #nav-secondarySearchTextbox, #headerSearchTextboxMini").one("focus", function() {
		$(this).val("");
	});
	$("#headerSearchTextbox").on("keyup",function() {
		$("#nav-secondarySearchTextbox, #headerSearchTextboxMini").val($(this).val());
	});
	$("#nav-secondarySearchTextbox").on("keyup",function() {
		$("#headerSearchTextbox, #headerSearchTextboxMini").val($(this).val());
	});
       $("#headerSearchTextboxMini").on("keyup",function() {
		$("#headerSearchTextbox, #nav-secondarySearchTextbox").val($(this).val());
	});
	
	//horizontalNav for Review Page navigation
	$('#reviewNav .articleColumns').horizontalNav({});
    
       
}); // END: doc.load
	    
  

// BEGIN: window.load
$(window).load(function() {

	'use strict';
	
	// filmstrip  (used for video splash)
	$('.filmstrip').filmstrip();
	
	//lightbox
	$(".inline").colorbox({inline:true, width:"75%"});
	
	// photo slider - used on Review Image Gallery
	$('.sliderPhoto').glider({
		controls: true,
		itemsToShow: 7,
		showCurrent: true
	});

});
// END: window.load

// BEGIN: window.resize
$(window).resize(function() {
		var windowSize = $(window).width();
		

		if (windowSize < 600 ) {
			$('#shopCompareFilter h4').show();
			$('#shopCompareFilter .splashBody').hide();
			$('#shopCompareFilter h4 a.toggle').click(
				function() {$('#shopCompareFilter .splashBody').toggle();}
			);
		}
			
		else {
				$('#shopCompareFilter .splashBody').show();
				$('#shopCompareFilter h4').hide();
			}
			
});

// END: window.resize

// BEGIN: plugins


/*
Bureau Plugin
    author: Morgan Wigmanich, TechTarget
    version: 1.1 (March 26 2012)
    description: @todo; didn't make this operate on classes (need ID) because of the 'open all topics' issue... should find a way around this
    options:
        showToggleAllButton: boolean; will display a button that will open/close all the 'drawers' at once
        showToggleAllButtonText: string; the text to display inside the button
    dependencies: none
*/
;(function ($) {

    'use strict';

    $.fn.bureau = function (options) {
        var defaults = {
            showToggleAllButton: false,
            showToggleAllButtonText: 'open all' /*mo.getString('open_all')*/
        };
        var o = $.extend(defaults, options);

        var bureau = $(this).find('.listTypeCollapsible');
        var drawers = bureau.find('> li');
        //var drawerContent = drawers.find('.listTypeCollapsibleContent');
        var drawerKnob = $('<span/>', {
            'class': 'drawerKnob'
        });
        var countOfDrawers = drawers.length;
        var countOfStuckDrawers = 0;

        // @todo comment
        var makeDrawer = {

            open: function (el) {
                var $this = $(el);
                $this.each( function () {
                    $(this)
                        .find('.listTypeCollapsibleContent')
                        .slideDown({
                            duration: 250,
                            easing: 'easeInCubic',
                            complete: function () {
                                $this.addClass('open');
                            }
                        });
                });
            },

            close: function (el) {
                var $this = $(el);
                $this.each( function () {
                    $(this)
                        .find('.listTypeCollapsibleContent')
                        .slideUp({
                        duration: 250,
                        easing: 'easeInCubic',
                        complete: function () {
                            $this.removeClass('open');
                        }
                        });
                });
            }

        };

        // @todo comment
        var toggleAllButton = $('<a href="#" class="openAllDrawers allClosed">' + o.showToggleAllButtonText + '</a>');
        var toggleAllDrawers = function (e) {
            e.preventDefault();
            var $this = $(this);
            if ($this.hasClass('allClosed')) {
                $this.removeClass('allClosed').text('close_all');
                makeDrawer.open($this.siblings('.listTypeCollapsible').find('> li').not('.stuck'));
            } else {
                $this.addClass('allClosed').text(o.showToggleAllButtonText);
                makeDrawer.close($this.siblings('.listTypeCollapsible').find('> li').not('.stuck'));
            }
        };

        // if the 'drawer' has something inside it, then add an arrow to indicate that to the user
        // if it doesn't, add a class of 'stuck' so that it won't open when the user clicks the list item
        drawers.each(function () {

            var drawer = $(this);
            var hasContent = drawer.find('.listTypeCollapsibleContent').children().size();

            if (hasContent) {
                drawer.append(drawerKnob.clone());
            } else {
                countOfStuckDrawers++;
                drawer.addClass('stuck');
            }

        });

        // if the drawer has a class of 'stuck' just allow the click to follow link
        // if drawer has a class of 'open', close the drawer unless user clicked on a link
        // otherwise open the drawer
        drawers.on('click', function (e){

            var $this = $(this);

            if (!$this.hasClass('stuck')) {
                if (!$this.hasClass('open')) {
                    e.preventDefault();
                    makeDrawer.open(this);
                } else if (e.target.className === 'drawerKnob') {
                    e.preventDefault();
                    makeDrawer.close(this);
                }
            }

        });

        // if the 'show all' option is selected and there's at least one drawer to open, add it to the dom and attach even handler
        if (o.showToggleAllButton && countOfDrawers !== countOfStuckDrawers) {
            toggleAllButton.insertBefore(bureau);
            toggleAllButton.on('click', toggleAllDrawers);
        }

    };

})(jQuery);

// filmstrip plugin
;(function($){

	'use strict';

	$.fn.filmstrip = function(options) {

		var defaults = {
			autoPlay: false,
			speed: 800,
			itemClick: function(){}
		};
		var opts = $.extend(defaults, options);

		return this.each(function() {

			var o = opts;
			var filmstrip = $(this);
			var filmstripWidth = filmstrip.width();
			var itemContainer = filmstrip.children('.filmstripWindow').children('.listTypeFilmstrip');
			var items = itemContainer.find('> li');
			var itemWidth = items.outerWidth();
			var itemCount = items.size();
			var itemContainerWidth = itemWidth * itemCount;
			var firstItem = items[0];
			var lastItem = items[itemCount - 1];
			var filmstripIsMoving = false;

			// depending on where on the page the filmstrip is located, it will display a different amount of items
			// this is determined by dividing the width of the filmstrip window by the width of the items and rounding up a bit
			var itemsToShow = Math.round(filmstripWidth/itemWidth);
			var movement = itemsToShow * itemWidth;
			var itemGroups = Math.ceil(itemCount/itemsToShow);
			var nowShowing = 1;

			// if all of the items are displayed, don't show the navigation arrows
			var navigation = ( itemCount <= itemsToShow ) ? false : true;

			// set width of container to make room for items
			itemContainer.width(itemContainerWidth);

			// callback function for clicking on item
			items.on('click', function(e){
				options.itemClick.call(this);
			});

			// @todo: this is idiotic
			function checkNav() {

				if (nowShowing === 1) {
					nextButton.removeClass('disabled');
					previousButton.addClass('disabled');
				} else if (nowShowing === itemGroups) {
					previousButton.removeClass('disabled');
					nextButton.addClass('disabled');
				} else {
					previousButton.removeClass('disabled');
					nextButton.removeClass('disabled');
				}

			}

			// moves the items in the strip container
			function moveStrip(direction) {

				// this prevents a queue buildup as the filmstrip is animating
				if (!filmstripIsMoving) {

					if (direction === 'right') {
						filmstripIsMoving = true;
						nowShowing++;
						itemContainer
							.stop()
							.animate({
								left: '-=' + movement
							}, {
								duration: o.speed,
								easing: 'easeOutExpo',
								complete: function(){
									filmstripIsMoving = false;
									checkNav();
								}
							});
					}

					if (direction === 'left') {
						filmstripIsMoving = true;
						nowShowing--;
						itemContainer
							.stop()
							.animate({
								left: '+=' + movement
							}, {
								duration: o.speed,
								easing: 'easeOutExpo',
								complete: function(){
									filmstripIsMoving = false;
									checkNav();
								}
							});
					}

				}

			}

			// displays the paging arrows on right and left of filmstrip
			if (navigation) {

				var previousButton = $('<a>', {
					'class' : 'filmstripPrevious disabled',
					href : '#',
					title : 'Previous',
					text : 'Previous'
				});

				var nextButton = $('<a>', {
					'class' : 'filmstripNext',
					href : '#',
					title : 'Next',
					text : 'Next'
				});


				var navContainer = $('<div/>', {
					'class': 'filmstripNavigation'
				})
				.append(previousButton, nextButton)
				.appendTo(filmstrip);

				navContainer.delegate('a', 'click', function (e) {
					e.preventDefault();
					if ($(this).hasClass('disabled')) {
						return;
					} else if ($(this).hasClass('filmstripPrevious')) {
						moveStrip('left');
					} else if ($(this).hasClass('filmstripNext')) {
						moveStrip('right');
					}
				});


			}

		});

	};

})(jQuery);
// End TechTarget custom plugins


/*!
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/; Copyright (c) 2008 George McGinley Smith; Easing equations Copyright (c) 2001 Robert Penner
 * Open source under the BSD License:
 */

/**
*
*
* Uses the built in easing capabilities added In jQuery 1.1
* to offer multiple easing options
*
* TERMS OF USE - jQuery Easing
*
* Open source under the BSD License.
*
* Copyright © 2008 George McGinley Smith
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
* Redistributions of source code must retain the above copyright notice, this list of
* conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list
* of conditions and the following disclaimer in the documentation and/or other materials
* provided with the distribution.
*
* Neither the name of the author nor the names of contributors may be used to endorse
* or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
* GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

/**
*
* TERMS OF USE - EASING EQUATIONS
*
* Open source under the BSD License.
*
* Copyright © 2001 Robert Penner
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
* Redistributions of source code must retain the above copyright notice, this list of
* conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list
* of conditions and the following disclaimer in the documentation and/or other materials
* provided with the distribution.
*
* Neither the name of the author nor the names of contributors may be used to endorse
* or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});
///////////////////////////////////////////////////
// ShowHide plugin                               
// Author: Ashley Ford - http://papermashup.com
// Demo: Tutorial - http://papermashup.com/jquery-show-hide-plugin
// Built: 19th August 2011                                     
///////////////////////////////////////////////////

(function ($) {
    $.fn.showHide = function (options) {

		//default vars for the plugin
        var defaults = {
            speed: 1000,
			easing: '',
			changeText: 0,
			showText: 'Show',
			hideText: 'Hide'
			
        };
        var options = $.extend(defaults, options);

        $(this).click(function () {	
           
             //$('.toggleDiv').slideUp(options.speed, options.easing);	
			 // this var stores which button you've clicked
             var toggleClick = $(this);
		     // this reads the rel attribute of the button to determine which div id to toggle
		     var toggleDiv = $(this).attr('rel');
		     // here we toggle show/hide the correct div at the right speed and using which easing effect
		     $(toggleDiv).slideToggle(options.speed, options.easing, function() {
		     // this only fires once the animation is completed
			 if(options.changeText==1){
		     $(toggleDiv).is(":visible") ? toggleClick.text(options.hideText) : toggleClick.text(options.showText);
			 }
              });
		   
		  return false;
		   	   
        });

    };
})(jQuery);

///////////////////////////////////////////////////
// ScrollToFixed plugin                               
// Author: BigSpottedDog
// GitHub: https://github.com/bigspotteddog/ScrollToFixed
///////////////////////////////////////////////////
(function($) {
    $.isScrollToFixed = function(el) {
        return $(el).data('ScrollToFixed') !== undefined;
    };

    $.ScrollToFixed = function(el, options) {
        // To avoid scope issues, use 'base' instead of 'this' to reference this
        // class from internal events and functions.
        var base = this;

        // Access to jQuery and DOM versions of element.
        base.$el = $(el);
        base.el = el;

        // Add a reverse reference to the DOM object.
        base.$el.data('ScrollToFixed', base);

        // A flag so we know if the scroll has been reset.
        var isReset = false;

        // The element that was given to us to fix if scrolled above the top of
        // the page.
        var target = base.$el;

        var position;

        // The offset top of the element when resetScroll was called. This is
        // used to determine if we have scrolled past the top of the element.
        var offsetTop = 0;

        // The offset left of the element when resetScroll was called. This is
        // used to move the element left or right relative to the horizontal
        // scroll.
        var offsetLeft = 0;
        var originalOffsetLeft = -1;

        // This last offset used to move the element horizontally. This is used
        // to determine if we need to move the element because we would not want
        // to do that for no reason.
        var lastOffsetLeft = -1;

        // This is the element used to fill the void left by the target element
        // when it goes fixed; otherwise, everything below it moves up the page.
        var spacer = null;

        var spacerClass;

        // Capture the original offsets for the target element. This needs to be
        // called whenever the page size changes or when the page is first
        // scrolled. For some reason, calling this before the page is first
        // scrolled causes the element to become fixed too late.
        function resetScroll() {
            // Set the element to it original positioning.
            target.trigger('preUnfixed');
            setUnfixed();
            target.trigger('unfixed');

            // Reset the last offset used to determine if the page has moved
            // horizontally.
            lastOffsetLeft = -1;

            // Capture the offset top of the target element.
            offsetTop = target.offset().top;

            // Capture the offset left of the target element.
            offsetLeft = target.offset().left;
            
            // If the offsets option is on, alter the left offset.
            if (base.options.offsets) {
                offsetLeft += (target.offset().left - target.position().left);
            }
            
            if (originalOffsetLeft == -1) {
                originalOffsetLeft = offsetLeft;
            }

            position = target.css('position');

            // Set that this has been called at least once.
            isReset = true;
            
            if (base.options.bottom != -1) {
                target.trigger('preFixed');
                setFixed();
                target.trigger('fixed');
            }
        }

        function getLimit() {
            var limit = base.options.limit;
            if (!limit) return 0;

            if (typeof(limit) === 'function') {
                return limit();
            }
            return limit;
        }

        // Returns whether the target element is fixed or not.
        function isFixed() {
            return position === 'fixed';
        }

        // Returns whether the target element is absolute or not.
        function isAbsolute() {
            return position === 'absolute';
        }

        function isUnfixed() {
            return !(isFixed() || isAbsolute());
        }

        // Sets the target element to fixed. Also, sets the spacer to fill the
        // void left by the target element.
        function setFixed() {
            // Only fix the target element and the spacer if we need to.
            if (!isFixed()) {
                // Set the spacer to fill the height and width of the target
                // element, then display it.
                spacer.css({
                    'display' : target.css('display'),
                    'width' : target.outerWidth(true),
                    'height' : target.outerHeight(true),
                    'float' : target.css('float')
                });

                // Set the target element to fixed and set its width so it does
                // not fill the rest of the page horizontally. Also, set its top
                // to the margin top specified in the options.
                target.css({
                    'width' : target.width(),
                    'position' : 'fixed',
                    'top' : base.options.bottom == -1?getMarginTop():'',
                    'bottom' : base.options.bottom == -1?'':base.options.bottom
                });

                position = 'fixed';
            }
        }

        function setAbsolute() {
            target.css({
                'width' : target.width(),
                'position' : 'absolute',
                'top' : getLimit(),
                'left' : offsetLeft
            });

            position = 'absolute';
        }

        // Sets the target element back to unfixed. Also, hides the spacer.
        function setUnfixed() {
            // Only unfix the target element and the spacer if we need to.
            if (!isUnfixed()) {
                lastOffsetLeft = -1;

                // Hide the spacer now that the target element will fill the
                // space.
                spacer.css('display', 'none');

                // Remove the style attributes that were added to the target.
                // This will reverse the target back to the its original style.
                target.css({
                    'width' : '',
                    'position' : '',
                    'left' : '',
                    'top' : ''
                });

                position = null;
            }
        }

        // Moves the target element left or right relative to the horizontal
        // scroll position.
        function setLeft(x) {
            // Only if the scroll is not what it was last time we did this.
            if (x != lastOffsetLeft) {
                // Move the target element horizontally relative to its original
                // horizontal position.
                target.css('left', offsetLeft - x);

                // Hold the last horizontal position set.
                lastOffsetLeft = x;
            }
        }

        function getMarginTop() {
            return base.options.marginTop;
        }

        // Checks to see if we need to do something based on new scroll position
        // of the page.
        function checkScroll() {
            var wasReset = isReset;

            // If resetScroll has not yet been called, call it. This only
            // happens once.
            if (!isReset) {
                resetScroll();
            }

            // Grab the current horizontal scroll position.
            var x = $(window).scrollLeft();

            // Grab the current vertical scroll position.
            var y = $(window).scrollTop();

            // Get the limit, if there is one.
            var limit = getLimit();

            // If the vertical scroll position, plus the optional margin, would
            // put the target element at the specified limit, set the target
            // element to absolute.
            if (base.options.minWidth && $(window).width() < base.options.minWidth) {
                if (!isUnfixed() || !wasReset) {
                    postPosition();
                    target.trigger('preUnfixed');
                    setUnfixed();
                    target.trigger('unfixed');
                }
            } else if (base.options.bottom == -1) {
                // If the vertical scroll position, plus the optional margin, would
                // put the target element at the specified limit, set the target
                // element to absolute.
                if (limit > 0 && y >= limit - getMarginTop()) {
                    if (!isAbsolute() || !wasReset) {
                        postPosition();
                        target.trigger('preAbsolute');
                        setAbsolute();
                        target.trigger('unfixed');
                    }
                // If the vertical scroll position, plus the optional margin, would
                // put the target element above the top of the page, set the target
                // element to fixed.
                } else if (y >= offsetTop - getMarginTop()) {
                    if (!isFixed() || !wasReset) {
                        postPosition();
                        target.trigger('preFixed');

                        // Set the target element to fixed.
                        setFixed();

                        // Reset the last offset left because we just went fixed.
                        lastOffsetLeft = -1;

                        target.trigger('fixed');
                    }
                    // If the page has been scrolled horizontally as well, move the
                    // target element accordingly.
                    setLeft(x);
                } else {
                    // Set the target element to unfixed, placing it where it was
                    // before.
                    if (!isUnfixed() || !wasReset) {
                        postPosition();
                        target.trigger('preUnfixed');
                        setUnfixed();
                        target.trigger('unfixed');
                    }
                }
            } else {
                if (limit > 0) {
                    if (y + $(window).height() - target.outerHeight(true) >= limit - getMarginTop()) {
                        if (isFixed()) {
                            postPosition();
                            target.trigger('preUnfixed');
                            setUnfixed();
                            target.trigger('unfixed');
                        }
                    } else {
                        if (!isFixed()) {
                            postPosition();
                            target.trigger('preFixed');
                            setFixed();
                        }
                        setLeft(x);
                        target.trigger('fixed');
                    }
                } else {
                    setLeft(x);
                }
            }
        }

        function postPosition() {
            var position = target.css('position');
            
            if (position == 'absolute') {
                target.trigger('postAbsolute');
            } else if (position == 'fixed') {
                target.trigger('postFixed');
            } else {
                target.trigger('postUnfixed');
            }
        }

        var windowResize = function(event) {
            // Check if the element is visible before updating it's position, which
            // improves behavior with responsive designs where this element is hidden.
            if(target.is(':visible')) {
                isReset = false;
                checkScroll();
			}
        }

        var windowScroll = function(event) {
            checkScroll();
        }

        // Initializes this plugin. Captures the options passed in, turns this
        // off for iOS, adds the spacer, and binds to the window scroll and
        // resize events.
        base.init = function() {
            // Capture the options for this plugin.
            base.options = $
                    .extend({}, $.ScrollToFixed.defaultOptions, options);

            // Turn off this functionality for iOS devices until we figure out
            // what to do with them, or until iOS5 comes out which is supposed
            // to support position:fixed.
            if (navigator.platform === 'iPad' || navigator.platform === 'iPhone' || navigator.platform === 'iPod') {
                if (!navigator.userAgent.match(/OS 5_.*\ like Mac OS X/i)) {
                    return;
                }
            }

            // Put the target element on top of everything that could be below
            // it. This reduces flicker when the target element is transitioning
            // to fixed.
            base.$el.css('z-index', base.options.zIndex);

            // Create a spacer element to fill the void left by the target
            // element when it goes fixed.
            spacer = $('');

            position = target.css('position');

            // Place the spacer right after the target element.
            if (isUnfixed()) base.$el.after(spacer);

            // Reset the target element offsets when the window is resized, then
            // check to see if we need to fix or unfix the target element.
            $(window).bind('resize.ScrollToFixed', windowResize);

            // When the window scrolls, check to see if we need to fix or unfix
            // the target element.
            $(window).bind('scroll.ScrollToFixed', windowScroll);
            
            if (base.options.preFixed) {
                target.bind('preFixed.ScrollToFixed', base.options.preFixed);
            }
            if (base.options.postFixed) {
                target.bind('postFixed.ScrollToFixed', base.options.postFixed);
            }
            if (base.options.preUnfixed) {
                target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);
            }
            if (base.options.postUnfixed) {
                target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);
            }
            if (base.options.preAbsolute) {
                target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);
            }
            if (base.options.postAbsolute) {
                target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);
            }
            if (base.options.fixed) {
                target.bind('fixed.ScrollToFixed', base.options.fixed);
            }
            if (base.options.unfixed) {
                target.bind('unfixed.ScrollToFixed', base.options.unfixed);
            }

            if (base.options.spacerClass) {
                spacer.addClass(base.options.spacerClass);
            }

            target.bind('resize.ScrollToFixed', function() {
                spacer.height(target.height());
            });

            target.bind('scroll.ScrollToFixed', function() {
                target.trigger('preUnfixed');
                setUnfixed();
                target.trigger('unfixed');
                checkScroll();
            });

            target.bind('remove.ScrollToFixed', function() {
                target.trigger('preUnfixed');
                setUnfixed();
                target.trigger('unfixed');

                $(window).unbind('resize.ScrollToFixed', windowResize);
                $(window).unbind('scroll.ScrollToFixed', windowScroll);

                target.unbind('.ScrollToFixed');
                base.$el.removeData('ScrollToFixed');
            });
            
            // Reset everything.
            windowResize();
        };

        // Initialize the plugin.
        base.init();
    };

    // Sets the option defaults.
    $.ScrollToFixed.defaultOptions = {
        marginTop : 0,
        limit : 0,
        bottom : -1,
        zIndex : 1000
    };

    // Returns enhanced elements that will fix to the top of the page when the
    // page is scrolled.
    $.fn.scrollToFixed = function(options) {
        return this.each(function() {
            (new $.ScrollToFixed(this, options));
        });
    };
})(jQuery);

/**
 * jQuery Horizontal Navigation 1.0
 * https://github.com/sebnitu/horizontalNav
 *
 * By Sebastian Nitu - Copyright 2012 - All rights reserved
 * Author URL: http://sebnitu.com
 */
(function($) {

    $.fn.horizontalNav = function(options) {

        // Extend our default options with those provided.
        var opts = $.extend({}, $.fn.horizontalNav.defaults, options);

        return this.each(function () {

            // Save our object
            var $this = $(this);

            // Build element specific options
            // This lets me access options with this syntax: o.optionName
            var o = $.meta ? $.extend({}, opts, $this.data()) : opts;

            // Save the wrapper. The wrapper is the element that
            // we figure out what the full width should be
            if ($this.is('ul')) {
                var ul_wrap = $this.parent();
            } else {
                var ul_wrap = $this;
            }

            // Grab elements we'll need and add some default styles
            var ul = $this.is('ul') ? $this : ul_wrap.find('> ul'), // The unordered list element
                li = ul.find('> li'), // All list items
                li_last = li.last(), // Last list item
                li_count = li.size(), // The number of navigation elements
                li_a = li.find('> a'); // Remove padding from the links

            if (o.minimumItems && o.minimumItems > li_count) {
                $this.addClass("horizontalNav-notprocessed");
                return false;
            }

            // If set to responsive, re-construct after every browser resize
            if ( o.responsive === true ) {
                // Only need to do this for IE7 and below
                // or if we set tableDisplay to false
                if ( (o.tableDisplay != true) || ($.browser.msie && parseInt($.browser.version, 10) <= 7) ) {
                    resizeTrigger( _construct, o.responsiveDelay );
                }
            }

            if ($('.clearHorizontalNav').length ) {
                ul_wrap.css({ 'zoom' : '1' });
            } else {
                ul_wrap.css({ 'zoom' : '1' }).append('<div class="clearHorizontalNav">');
                // let's append a clearfixing element to the ul wrapper
                $('.clearHorizontalNav').css({
                'display' : 'block',
                'overflow' : 'hidden',
                'visibility' : 'hidden',
                'width' : 0,
                'height' : 0,
                'clear' : 'both'
                });
            }

            // Initiate the plugin
            _construct();

            // Returns the true inner width of an element
            // Essentially it's the inner width without padding.
            function trueInnerWidth(element) {
                return element.innerWidth() - (
                    parseInt(element.css('padding-left')) + parseInt(element.css('padding-right'))
                );
            }

            // Call funcion on browser resize
            function resizeTrigger(callback, delay) {
                // Delay before function is called
                delay = delay || 100;
                // Call function on resize
                var resizeTimer;
                $(window).resize(function() {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(function() {
                        callback();
                    }, delay);
                });
            }

            // The heavy lifting of this plugin. This is where we
            // find and set the appropriate widths for list items
            function _construct() {

                if ( (o.tableDisplay != true) || ($.browser.msie && parseInt($.browser.version, 10) <= 7) ) {

                    // IE7 doesn't support the "display: table" method
                    // so we need to do it the hard way.

                    // Add some styles
                    ul.css({ 'float' : 'left' });
                    li.css({ 'float' : 'left', 'width' : 'auto' });
                    li_a.css({ 'padding-left' : 0, 'padding-right' : 0 });

                    // Grabbing widths and doing some math
                    var ul_width = trueInnerWidth(ul),
                        ul_width_outer = ul.outerWidth(true),
                        ul_width_extra = ul_width_outer - ul_width,

                        full_width = trueInnerWidth(ul_wrap),
                        extra_width = (full_width - ul_width_extra) - ul_width,
                        li_padding = Math.floor( extra_width / li_count );

                    // Cycle through the list items and give them widths
                    li.each(function(index) {
                        var li_width = trueInnerWidth( $(this) );
                        $(this).css({ 'width' : (li_width + li_padding) + 'px' });
                    });

                    // Get the leftover pixels after we set every itms width
                    var li_last_width = trueInnerWidth(li_last) + ( (full_width - ul_width_extra) - trueInnerWidth(ul) );
                    // I hate to do this but for some reason Firefox (v13.0) and IE are always
                    // one pixel off when rendering. So this is a quick fix for that.
                    if ($.browser.mozilla || $.browser.msie) {
                        li_last_width = li_last_width - 1;
                    }
                    // Add the leftovers to the last navigation item
                    li_last.css({ 'width' : li_last_width + 'px' });

                } else {
                    // Every modern browser supports the "display: table" method
                    // so this is the best way to do it for them.
                    ul.css({ 'display' : 'table', 'float' : 'none', 'width' : '100%' });
                    li.css({ 'display' : 'table-cell', 'float' : 'none', 'width' : '30%' });
                }
                $this.addClass("horizontalNav-processed").removeClass("horizontalNav-notprocessed");
            }

        }); // @end of return this.each()

    };

    $.fn.horizontalNav.defaults = {
        responsive : true,
        responsiveDelay : 100,
        tableDisplay : true,
        minimumItems : 0
    };

})(jQuery);










/*
 * RoyalSlider
 *
 * @version 9.2.0:
 *
 * Copyright 2011-2012, Dmitry Semenov
 * 
 */

(function($) {
	if(!$.rsModules) {
		$.rsModules = {};
	}
	function RoyalSlider(element, options) {
		var ua = navigator.userAgent.toLowerCase(),
			i,
			br = $.browser,
			self = this,
			isWebkit = br.webkit,
			isAndroid = ua.indexOf('android') > -1;
		self.isIPAD = ua.match(/(ipad)/);

		// feature detection, some ideas taken from Modernizr
		var tempStyle = document.createElement('div').style,
			vendors = ['webkit','Moz','ms','O'],
			vendor = '',
			lastTime = 0,
			tempV;

		for (i = 0; i < vendors.length; i++ ) {
			tempV = vendors[i];
			if (!vendor && (tempV + 'Transform') in tempStyle ) {
				vendor = tempV;
			}
			tempV = tempV.toLowerCase();
			
			if(!window.requestAnimationFrame) {
				window.requestAnimationFrame = window[tempV+'RequestAnimationFrame'];
       			window.cancelAnimationFrame = window[tempV+'CancelAnimationFrame'] 
                                   || window[tempV+'CancelRequestAnimationFrame'];
			}
		}

 		// requestAnimationFrame polyfill by Erik Möller
		// fixes from Paul Irish and Tino Zijdel
	    if (!window.requestAnimationFrame) {
	        window.requestAnimationFrame = function(callback, element) {
	            var currTime = new Date().getTime(),
	            	timeToCall = Math.max(0, 16 - (currTime - lastTime)),
	            	id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
	            lastTime = currTime + timeToCall;
	            return id;
	        };
	    }
	    if (!window.cancelAnimationFrame) 
	    	window.cancelAnimationFrame = function(id) { clearTimeout(id); };

	    self.slider = $(element);
		self.ev = $({}); // event object
		self._doc = $(document);
		self.st = $.extend({}, $.fn.royalSlider.defaults, options); 
		self._currAnimSpeed = self.st.transitionSpeed;
 
		if(self.st.allowCSS3) {
			if((!isWebkit || self.st.allowCSS3OnWebkit) ) {
		    	var bT = vendor + (vendor ? 'T' : 't' );
		    	self._useCSS3Transitions = ( (bT + 'ransform') in tempStyle ) && ( (bT + 'ransition') in tempStyle );
			    if(self._useCSS3Transitions) {
			    	self._use3dTransform = (vendor + (vendor ? 'P' : 'p'  ) + 'erspective') in tempStyle;
			    }
		    }
		}
	    
	    vendor = vendor.toLowerCase();
	    self._vendorPref = '-'+vendor+'-';
		
		self._slidesHorizontal = (self.st.slidesOrientation === 'vertical') ? false : true;
		self._reorderProp = self._slidesHorizontal ? 'left' : 'top';
		self._sizeProp = self._slidesHorizontal ? 'width' : 'height';
		self._prevNavItemId = -1;
		self._isMove = (self.st.transitionType === 'fade') ? false : true;
		if(!self._isMove) {
			self.st.sliderDrag = false;
			self._fadeZIndex = 10;
		}

		self._newSlideId = 0;
		self._sPosition = 0;

		// init modules
		$.each($.rsModules, function (helper, opts) {
			opts.call(self);
		});

		// parse all slides
		self.slides = [];
		self._idCount = 0;
		var returnVal;
		var ts = self.st.slides ? $(self.st.slides) : self.slider.children().detach();
		
		ts.each(function() {
			self._parseNode(this, true);
		});

		if(self.st.randomizeSlides) {
	    	self.slides.sort(function() { return 0.5 - Math.random() });
	    }
		self.numSlides = self.slides.length;
		self._refreshNumPreloadImages();


		if(self.st.startSlideId > self.numSlides - 1) {
			self.st.startSlideId = self.numSlides - 1;
		}

		self.staticSlideId = self.currSlideId = self._realId =  self.st.startSlideId;
		self.currSlide = self.slides[self.currSlideId];

		self._accelerationPos = 0;

		self.slider.addClass( (self._slidesHorizontal ? 'rsHor' : 'rsVer') + (self._isMove ? '' : ' rsFade') );

		var sliderHTML = '<div class="rsOverflow"><div class="rsContainer">';
		self.slidesSpacing = self.st.slidesSpacing;
		self._slideSize = ( self._slidesHorizontal ? self.slider.width() : self.slider.height() ) + self.st.slidesSpacing;

		self._preload = Boolean(self._numPreloadImages > 0);
		
		if(self.numSlides <= 1) {
			self._loop = false;
		}
		var loopHelpers = (self._loop && self._isMove) ? ( self.numSlides === 2 ? 1 : 2) : 0;
		self._loopHelpers = loopHelpers;

		self._maxImages = self.numSlides < 6 ? self.numSlides : 6;
		self._currBlockIndex = 0;


		self._idOffset = 0;
		self.slidesJQ = [];
		
		for(i =0; i < self.numSlides; i++) {
			self.slidesJQ.push( $(createItemHTML(i)) );
		}
		
		sliderHTML += '</div></div>';

		self.slider.html(sliderHTML);


		self._sliderOverflow = self.slider.children('.rsOverflow');
		self._slidesContainer = self._sliderOverflow.children('.rsContainer');
		self._preloader = $('<div class="rsPreloader"></div>');

		var slides = self._slidesContainer.children('.rsSlide');

		self._currHolder = self.slidesJQ[self.currSlideId]
		self._selectedSlideHolder = 0;

		function createItemHTML(i, className) {
			return '<div style="'+ (self._isMove ? '' : (i !== self.currSlideId  ? 'z-index: 0; display:none; opacity: 0; position: absolute;  left: 0; top: 0;' : 'z-index: 0;  position: absolute; left: 0; top: 0;') ) +'" class="rsSlide '+ (className || '')+'"></div>';
		}

		if('ontouchstart' in window || 'createTouch' in document) {
			self.hasTouch = true;
			self._downEvent = 'touchstart.rs';
			self._moveEvent = 'touchmove.rs';
			self._upEvent = 'touchend.rs';
			self._cancelEvent = 'touchcancel.rs';
			self._lastItemFriction = 0.5;
		} else {
			self.hasTouch = false;
			self._lastItemFriction = 0.2;
			
			if(self.st.sliderDrag) {
				if (br.msie || br.opera) {
					self._grabCursor = self._grabbingCursor = "move";
				} else if(br.mozilla) {
					self._grabCursor = "-moz-grab";
					self._grabbingCursor = "-moz-grabbing";
				} else if(isWebkit && (navigator.platform.indexOf("Mac")!=-1)) {
					self._grabCursor = "-webkit-grab";
					self._grabbingCursor = "-webkit-grabbing";
				}
				self._setGrabCursor();
			}

			self._downEvent = 'mousedown.rs';
			self._moveEvent = 'mousemove.rs';
			self._upEvent = 'mouseup.rs';
			self._cancelEvent = 'mouseup.rs';
		}
		
		if(self._useCSS3Transitions) {

			// some constants for CSS3
			self._TP = 'transition-property';
			self._TD = 'transition-duration';
			self._TTF = 'transition-timing-function';

			self._yProp = self._xProp = self._vendorPref +'transform';

			if(self._use3dTransform) {
				if(isWebkit) {
					self.slider.addClass('rsWebkit3d');
				}

				self._tPref1 = 'translate3d(';
				self._tPref2 = 'px, ';
				self._tPref3 = 'px, 0px)';
			} else {
				self._tPref1 = 'translate(';
				self._tPref2 = 'px, ';
				self._tPref3 = 'px)';
			}
			if(!self._isMove) {
				var animObj = {};
				animObj[(self._vendorPref + self._TP)] = 'opacity';
				animObj[(self._vendorPref + self._TD)] = self.st.transitionSpeed + 'ms';
				animObj[(self._vendorPref + self._TTF)] = self.st.css3easeInOut;
				slides.css(animObj);
			} else {
				self._slidesContainer[(self._vendorPref + self._TP)] = (self._vendorPref + 'transform');
			}
			

		} else {
			self._xProp = 'left';
			self._yProp = 'top';
		}

		

		// resize
		var resizeTimer;
		$(window).on('resize.rs', function() {	
			if(resizeTimer) {
				clearTimeout(resizeTimer);			
			}
			resizeTimer = setTimeout(function() { self.updateSliderSize(); }, 50);			
		});	
		
	
		self.ev.trigger('rsAfterPropsSetup'); // navigation (bullets, thumbs...) is created here
		self.updateSliderSize();


		// keyboard nav
		if(self.st.keyboardNavEnabled) {
			self._bindKeyboardNav();
		}

		if(self.st.arrowsNavHideOnTouch && self.hasTouch)	 {
			self.st.arrowsNav = false;
		}

		//Direction navigation (arrows)
		if(self.st.arrowsNav) {
			var rArr = 'rsArrow',
				container = self.st.controlsInside ? self._sliderOverflow : self.slider;
			$('<div class="'+rArr+' '+rArr+'Left"><div class="'+rArr+'Icn"></div></div><div class="'+rArr+' '+rArr+'Right"><div class="'+rArr+'Icn"></div></div>').appendTo(container);

			self._arrowLeft = container.children('.'+rArr+'Left').click(function(e) {
				e.preventDefault();
				self.prev();
			});
			self._arrowRight = container.children('.'+rArr+'Right').click(function(e) {
				e.preventDefault();
				self.next();
			});

			if(self.st.arrowsNavAutoHide && !self.hasTouch) {
				self._arrowLeft.addClass('rsHidden');
				self._arrowRight.addClass('rsHidden');

				var hoverEl = container;
				hoverEl.one("mousemove.arrowshover",function() {
					self._arrowLeft.removeClass('rsHidden');
					self._arrowRight.removeClass('rsHidden');			
				});


				hoverEl.hover(
					function() {
						if(!self._arrowsAutoHideLocked) {
							self._arrowLeft.removeClass('rsHidden');
							self._arrowRight.removeClass('rsHidden');
						}
					},
					function() {
						if(!self._arrowsAutoHideLocked) {
							self._arrowLeft.addClass('rsHidden');
							self._arrowRight.addClass('rsHidden');
						}
					}
				);	
			}	
			self.ev.on('rsOnUpdateNav', function() {
				self._updateArrowsNav();
			});
			self._updateArrowsNav();
		}

			
		
		self._hasDrag = (!self.hasTouch && self.st.sliderDrag) ||  (self.hasTouch && self.st.sliderTouch);
		if( self._hasDrag ) {
			self._slidesContainer.on(self._downEvent, function(e) { self._onDragStart(e); });	
		} else {
			self.dragSuccess = false;
		}
		var videoClasses = ['rsPlayBtnIcon', 'rsPlayBtn', 'rsCloseVideoBtn', 'rsCloseVideoIcn'];
			self._slidesContainer.click(function(e) {
				if(!self.dragSuccess) {
					var t = $(e.target);
					var tClass = t.attr('class');
					if( $.inArray(tClass, videoClasses) !== -1) {
				        if( self.toggleVideo() ) {
							return false;
						}
				    }
					if(self.st.navigateByClick && !self._blockActions) {
						if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
							 return true;
						}
						self._mouseNext(e);
					} 
				} 
			});
		//}

		self.ev.trigger('rsAfterInit');
	} /* RoyalSlider Constructor End */

	/**
	 *
	 * RoyalSlider Core Prototype
	 * 
	 */
	RoyalSlider.prototype = {
		_mouseNext: function(e) {
			var self = this;
		  	var relativeX = e[self._slidesHorizontal ? 'pageX' : 'pageY'] - self._sliderOffset
		  	if(relativeX > 0) {
		  		self.next();
		  	} else {
		  		self.prev();
		  	}
		},
		_refreshNumPreloadImages: function() {
			var self = this,
				n;
			n = self.st.numImagesToPreload;
			self._loop = self.st.loop;

			if(self._loop) {
				if(self.numSlides === 2) {
					self._loop = false;
					self.st.loopRewind = true;
				} else if(self.numSlides < 2) {
					self.st.loopRewind = self._loop = false;
				}
				
			}
			if(self._loop && n > 0) {
				if(self.numSlides <= 4) {
					n = 1;
				} else {
					if(self.st.numImagesToPreload > (self.numSlides - 1) / 2 ) {
						n = Math.floor( (self.numSlides - 1) / 2 );
					}
				} 
			}
			self._numPreloadImages = n;
		},
		_parseNode: function(content, pushToSlides) {
			var self = this,
				hasImg,
				isRoot,
				hasCover,
				obj = {};
			content = $(content);
			self._currContent = content;
			self.ev.trigger('rsBeforeParseNode', [content, obj]);
			if(obj.stopParsing) {
				return;
			}
			content = self._currContent;
			obj.id = self._idCount;
			obj.contentAdded = false;
			self._idCount++;

			
			if(!obj.hasCover) {
				if(content.hasClass('rsImg')) {
					tempEl = content;
					hasImg = true;
				} else {
					tempEl = content.find('.rsImg');
					if(tempEl.length) {
						hasImg = true;
					}
				}

				if(hasImg) {
					obj.bigImage = tempEl.attr('data-rsBigImg');
					if(tempEl.is('a')) {
						parseEl(tempEl, 'href');
					} else if(tempEl.is('img')) {
						parseEl(tempEl);
					}
				} else if(content.is('img')) {
					content.addClass('rsImg');
					parseEl(content);
				}
			}
			tempEl = content.find('.rsCaption');
			if(tempEl.length) {
				obj.caption = tempEl.remove();
			}
			if(!obj.image) {
				obj.isLoaded = true;
				obj.isRendered = false;
				obj.isLoading = false;
			}
			obj.content = content;
			self.ev.trigger('rsAfterParseNode', [content, obj]);
			function parseEl(el, s) {
				obj.image = el.attr(!s ? 'src' : s);
				obj.caption = !s ? el.attr('alt') : el.contents();
				obj.videoURL = el.attr('data-rsVideo');
			}
			if(pushToSlides) {
				self.slides.push(obj);
			}
			return obj;
		},
		_bindKeyboardNav: function() {
			var self = this;
			self._doc.on('keydown.rskb', function(e) {
				if(!self._isDragging && !self._isAnimating) {
					if (e.keyCode === 37) {
						e.preventDefault();
						self.prev();
					} else if (e.keyCode === 39) {
						e.preventDefault();
						self.next();
					}
				}
			});
		},
		goTo: function(id, notUserAction) {
			var self = this;
			if(id !== self.currSlideId) {
				self._moveTo(id,self.st.transitionSpeed, true, !notUserAction);
			}
		},
		destroy: function(remove) {
			var self = this;
			self.ev.trigger('rsBeforeDestroy');
			self._doc.off('keydown.rskb ' + self._moveEvent +' '+ self._upEvent );
			self._slidesContainer.on(self._downEvent, function(e) { self._onDragStart(e); });	
			self.slider.data('royalSlider', '');
			if(remove) {
				self.slider.remove();
			}
		},
		_updateBlocksContent: function(beforeTransition, getId) {
			var self = this,
				item,
				i,
				n,
				pref,
				group,
				groupId,
				slideCode,
				loop = self._loop,
				numSlides = self.numSlides;
			if(!isNaN(getId) ) {
				return getCorrectLoopedId(getId);
			}

			var id = self.currSlideId;
			var groupOffset;
			
			var itemsOnSide = beforeTransition ? (Math.abs(self._prevSlideId - self.currSlideId) >= self.numSlides - 1 ? 0 : 1) : self._numPreloadImages;
			var itemsToCheck = Math.min(2, itemsOnSide); 
			
			var updateAfter = false;
			var updateBefore = false;
			var tempId;


			
			for(i = id; i < id + 1 + itemsToCheck; i++) {
				tempId = getCorrectLoopedId(i);
				item = self.slides[tempId];
				if(item && (!item.isAdded || !item.positionSet) ) {
					updateAfter = true;
					break;
				}
			}
			for(i = id - 1; i > id - 1 - itemsToCheck; i--) {
				tempId = getCorrectLoopedId(i);
				item = self.slides[tempId];
				if(item && (!item.isAdded || !item.positionSet) ) {
					updateBefore = true;
					break;
				}
			}
			if(updateAfter) {
				for(i = id; i < id + itemsOnSide + 1; i++) {
					tempId = getCorrectLoopedId(i);
					groupOffset = Math.floor( (self._realId - (id - i)) / self.numSlides) * self.numSlides;
					item = self.slides[tempId];
					if(item) {
						updateItem(item, tempId);	
					}
				}
			}
			if(updateBefore) {
				for(i = id - 1; i > id - 1 - itemsOnSide; i--) {
					tempId = getCorrectLoopedId(i);
					groupOffset = Math.floor( (self._realId - (id - i) ) / numSlides) * numSlides;
					item = self.slides[tempId];
					if(item) {
						updateItem(item, tempId);
					}
				}
			}
			if(!beforeTransition) {
				var start = id;
				var distance = itemsOnSide;
				var min = getCorrectLoopedId(id - itemsOnSide);
				var max = getCorrectLoopedId(id + itemsOnSide);
				
				var nmin = min > max ? 0 : min;
				
				for (i = 0; i < numSlides; i++) { 
					if(min > max) {
						if(i > min - 1) {
							continue;
						}
					}
					if(i < nmin || i > max) {
						 item = self.slides[i];
						if(item && item.holder) {
							
							//slideCode = self.slidesJQ[i];
							//if(typeof slideCode !== "string") { 
								item.holder.detach();
								item.isAdded = false;
							//}
						}     
					}                               
			    }   
			}

			
			
				
				
			function updateItem(item , i, slideCode) {

				if(!item.isAdded) {
					if(!slideCode)
						slideCode = self.slidesJQ[i];

					if(!item.holder) {
						slideCode = self.slidesJQ[i] = $(slideCode);
						item.holder = slideCode;
					} else {
						slideCode = item.holder;
					}

					item.appendOnLoaded = false;

					
					updatePos(i, item, slideCode);
					addContent(i, item);
					self._addBlockToContainer(item, slideCode, beforeTransition);
					item.isAdded = true;
					appended = true;
				} else {
					addContent(i, item);
					updatePos(i, item);
				}
			}
			function addContent(i, item) {
				if(!item.contentAdded) {
					self.setItemHtml(item, beforeTransition);
					if(!beforeTransition) {
						item.contentAdded = true;
					}
					
				}
			}
			function updatePos(i, item, slideCode) {
				if(self._isMove) {
					if(!slideCode) {
						slideCode = self.slidesJQ[i];
					}
					slideCode.css(self._reorderProp, (i + self._idOffset + groupOffset) * self._slideSize);
				}
			}
			function getCorrectLoopedId(index) {
				var changed = false;
				if(loop) {
					if(index > numSlides - 1) {
						return getCorrectLoopedId(index - numSlides);
					} else  if(index < 0) {
						return getCorrectLoopedId(numSlides + index);
					}
				}
				return index;
			}
			
		},

		/**
		 * Sets or loads HTML for specified slide
		 * @param {Object} currSlideObject  holds data about curr slide (read about rsAfterParseNode for more info)
		 * @param {Boolean} beforeTransition determines if setItemHTML method is called before or after transition
		 */
		setItemHtml: function(currSlideObject, beforeTransition) {
			var self = this;
			var content = currSlideObject.content;
			var holder = currSlideObject.holder;

			var onImageLoaded = function (slideObject) {
				var sizeType = slideObject.sizeType;
			    return function (e) {
			    	var content = slideObject.content,
			    		holder = slideObject.holder;

			    	if(e) {
			    		var newImg = e.currentTarget;
			    		$(newImg).off('load error');
			    		if(e.type === 'error') {
			    			slideObject.isLoaded = true;
							slideObject.image = '';
							slideObject.isLoading = false;
							content.addClass('rsSlideError');
							holder.html(content);
							slideObject.holder.trigger('rsAfterContentSet');
							self.ev.trigger('rsAfterContentSet', slideObject);
			    			return;
			    		}
			    	}

					if(slideObject.image) {
						if(slideObject.bigImage && slideObject.sizeType !== sizeType) {
							if(sizeType === 'med') {
								slideObject.isMedLoading = false;
							} else if(sizeType === 'big') {
								slideObject.isBigLoading = false;
							} else {
								slideObject.isMedLoading = slideObject.isLoading = false;
							}
				    		return;
				    	}
						if(!slideObject.isLoaded) {
							var tempEl,
								isRoot;
							if(content.hasClass('rsImg')) {
								isRoot = true;
								tempEl = content;
							} else {
								isRoot = false;
								tempEl = content.find('.rsImg');
							}
							if(tempEl.length && tempEl.is('a')) {
								
								if(isRoot) {
									content = $('<img class="rsImg" src="'+slideObject.image+'" />');
								} else {
									content.find('.rsImg').replaceWith('<img class="rsImg" src="'+slideObject.image+'" />');
								}
								slideObject.content = content;
							}
							
							slideObject.iW = newImg.width;
							if(slideObject.iW > 0) {
								slideObject.iH = newImg.height;
								slideObject.isLoaded = true;
								slideObject.isLoading = false;
								self._resizeImage( slideObject );
							}
						} else {
							
							if(!slideObject.isRendered && beforeTransition) {
								waitForTransition();
								return;
							}
							self._resizeImage( slideObject );
						}
					} else {
						if(!self._preload && beforeTransition && !slideObject.isRendered) {
							slideObject.isRendered = true;
							waitForTransition();
							return;
						}
						slideObject.isLoaded = true;
						slideObject.isLoading = false;
					}


					var visibleNearby = false;
					var bId = slideObject.id - self._newSlideId;
					if(!beforeTransition && !slideObject.appendOnLoaded && self.st.fadeinLoadedSlide  && ( bId === 0 || ( (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1) ) ) ) {
						content.css(self._vendorPref + 'transition', 'opacity 400ms ease-in-out').css({visibility: 'visible', opacity: 0});
						holder.html(content);
						setTimeout(function() {
							content.css('opacity', 1);
						}, 6);
					} else {
						holder.html(content);
					}
					
					slideObject.isRendered = true;

					holder.find('a').off('click.rs').on('click.rs', function(e) {	
						if(self.dragSuccess) {						
							return false;
						} else {
							self._blockActions = true;
							self.ev.trigger('rsSlideClick');
							//e.stopPropagation();
							//e.stopImmediatePropagation();
							setTimeout(function() {
								self._blockActions = false;
							}, 3);
						}
					});
					slideObject.holder.trigger('rsAfterContentSet');
					self.ev.trigger('rsAfterContentSet', slideObject);

					if(slideObject.appendOnLoaded) {
						self._addBlockToContainer(slideObject, content, beforeTransition);
					}
			    };
			};

		
			if(currSlideObject.isLoaded) {
				onImageLoaded(currSlideObject)();
			} else {
				if(beforeTransition) {
					waitForTransition();
				} else {
					parseDataAndLoad();
				}
			}

			function parseDataAndLoad() {
				if(!currSlideObject.image) {
					onImageLoaded(currSlideObject)();
					return;
				}
								

				if(!currSlideObject.isLoading) {
					loadImg($('<img/>'), currSlideObject.image);
				} else {
					var guard = 1;
					function loopUntilLoaded(sizeType) {
						var s = sizeType === 'big' ? currSlideObject.isBigLoaded : currSlideObject.isMedLoaded;
						if(!currSlideObject.isLoading) {
							return;
						}
						if(currSlideObject.isLoaded) {
							onImageLoaded(currSlideObject)();
							return;
						}
						if(guard % 50 === 0) {
							var l = currSlideObject.imageLoader;
							if(l.complete && l.naturalWidth !== undefined && l.naturalWidth !== 0 &&  l.naturalHeight !== 0) {
								onImageLoaded(currSlideObject)();
								return;
							}
						}
						if(guard > 300) {
							return;
						}
						setTimeout(loopUntilLoaded, 400);
						guard++;
					}
					loopUntilLoaded(currSlideObject.sizeType);
				}
				
			}
			
			function loadImg(lImg, src) {
				if(!beforeTransition) {
					if(!currSlideObject.isLoading) {
						if(!src) {
							src = lImg.attr('src');
							lImg = $("<img/>");
						}

						setPreloader(holder);
						
						currSlideObject.isLoading = true;
						currSlideObject.imageLoader = lImg;
						lImg.one('load error',onImageLoaded(currSlideObject)).attr('src', src);
						
					}
				} else {
					waitForTransition();
				}
			}
			function isImageLoaded(limg) {
				if(limg) {
					if (!limg.complete || limg.naturalWidth === undefined || limg.naturalWidth === 0) {
				        return false;
				    }
				} else {
					return false;
				}
			    return true;	
			}
			function waitForTransition() {
				holder.isWaiting = true;
				setPreloader(holder);
				holder.slideId = -99;
			}
			function setPreloader(holder) {
				currSlideObject.holder.html(self._preloader.clone());
			}
		},
		_addBlockToContainer: function(slideObject, content, dontFade) {
			var self = this;
			var holder = slideObject.holder;
			var bId = slideObject.id - self._newSlideId;
			
			var visibleNearby = false;
			if(self._isMove && !dontFade && self.st.fadeinLoadedSlide  && ( bId === 0 || ( (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1) ) ) ) {
				var content = slideObject.content;
				content.css(self._vendorPref + 'transition', 'opacity 400ms ease-in-out').css({visibility: 'visible', opacity: 0});
				//holder.css('opacity', 0);
				self._slidesContainer.append(holder);
				setTimeout(function() {
					content.css('opacity', 1);
					//self.ev.trigger('rsAfterContentSet', holder);
				}, 6);
			} else {
				self._slidesContainer.append(holder);
			}
			slideObject.appendOnLoaded = false;
		},
	
		_onDragStart:function(e, isThumbs) {
			var self = this,
				point,
				wasAnimating;
			self.dragSuccess = false;

			if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
				 return true;
			}

			
			if(!isThumbs) {
				if(self._isAnimating) {
					wasAnimating = true;
					self._stopAnimation();
				}
			}
			
			if(self._isDragging) {
				if(self.hasTouch) {
					self._multipleTouches = true;
				}
				return;
			} else {
				if(self.hasTouch) {
					self._multipleTouches = false;
				}
			}

			self._setGrabbingCursor();
			
			if(self.hasTouch) {
				//parsing touch event
				var touches = e.originalEvent.touches;
				if(touches && touches.length > 0) {
					point = touches[0];
					if(touches.length > 1) {
						self._multipleTouches = true;
					}
				}					
				else {	
					return;						
				}
			} else {
				point = e;						
				e.preventDefault();					
			}

			self._isDragging = true;
			self._doc.on(self._moveEvent, function(e) { self._onDragMove(e, isThumbs); })
						.on(self._upEvent, function(e) { self._onDragRelease(e, isThumbs); });
			
			self._currMoveAxis = '';
			self._hasMoved = false;
			self._pageX = point.pageX;
			self._pageY = point.pageY;
			self._startPagePos = self._accelerationPos = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal) ? point.pageX : point.pageY;

			
			
			self._horDir = 0;
			self._verDir = 0;

			self._currRenderPosition = !isThumbs ? self._sPosition : self._thumbsPosition;

			self._startTime = new Date().getTime();
			if(self.hasTouch) {
				self._sliderOverflow.on(self._cancelEvent, function(e) { self._onDragRelease(e, isThumbs); });	
			}
		},
		_renderMovement:function(point, isThumbs) {
			var self = this;
			if(self._checkedAxis) {
				var timeStamp = self._renderMoveTime,
					deltaX = point.pageX - self._pageX,
					deltaY = point.pageY - self._pageY,
					newX = self._currRenderPosition + deltaX,
					newY = self._currRenderPosition + deltaY,
					isHorizontal = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
					newPos = isHorizontal ? newX : newY,
					mAxis = self._currMoveAxis;

				self._hasMoved = true;
				self._pageX = point.pageX;
				self._pageY = point.pageY;

				var pointPos = isHorizontal ? self._pageX : self._pageY;

				if(mAxis === 'x' && deltaX !== 0) {
					self._horDir = deltaX > 0 ? 1 : -1;
				} else if(mAxis === 'y' && deltaY !== 0) {
					self._verDir = deltaY > 0 ? 1 : -1;
				}
				
				var deltaPos = isHorizontal ? deltaX : deltaY;
				if(!isThumbs) {
					if(!self._loop) {
						if(self.currSlideId <= 0) {
							if(pointPos - self._startPagePos > 0) {
								newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
							}
						}
						if(self.currSlideId >= self.numSlides - 1) {
							if(pointPos - self._startPagePos < 0) {
								newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
							}
						}
					}
				} else {
					if(newPos > self._thumbsMinPosition) {
						newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
					} else if(newPos < self._thumbsMaxPosition) {
						newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
					}
				}

				self._currRenderPosition = newPos;
				
				if (timeStamp - self._startTime > 200) {
			 		self._startTime = timeStamp;
					self._accelerationPos = pointPos;						
				}

				if(!isThumbs) {
					if(self._isMove) {
						self._setPosition(self._currRenderPosition);
					}
				} else {
					self._setThumbsPosition(self._currRenderPosition);
				}
			}
			
			
		},
		_onDragMove:function(e, isThumbs) {
			var self = this;
			if(self.hasTouch) {
				if(self._lockAxis) {
					return;
				}	
				var touches = e.originalEvent.touches;
				if(touches) {
					if(touches.length > 1) {
						return;
					} else {
						point = touches[0];	
					}
				} else {
					return;
				}
			} else {
				point = e;
			}
			
			if(!self._hasMoved) {
				if(self._useCSS3Transitions) {
					(!isThumbs ? self._slidesContainer : self._thumbsContainer).css((self._vendorPref + self._TD), '0s');
				}
				(function animloop(){
					if(self._isDragging) {
						self._animFrame = requestAnimationFrame(animloop);
						if(self._renderMoveEvent)
							self._renderMovement(self._renderMoveEvent, isThumbs);
					}
					
			    })();
			}
				
			if(!self._checkedAxis) {
				
				var dir = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
					diff = (Math.abs(point.pageX - self._pageX) - Math.abs(point.pageY - self._pageY) ) - (dir ? -7 : 7);

				if(diff > 7) {
					// hor movement
					if(dir) {
						e.preventDefault();
						self._currMoveAxis = 'x';
					} else if(self.hasTouch) {
						self._completeGesture();
						return;
					} 
					self._checkedAxis = true;
				} else if(diff < -7) {
					// ver movement
					if(!dir) {
						e.preventDefault();
						self._currMoveAxis = 'y';
					} else if(self.hasTouch) {
						self._completeGesture();
						return;
					} 
					self._checkedAxis = true;
				}
				return;
			}
			
			e.preventDefault();	
			self._renderMoveTime = new Date().getTime();
			self._renderMoveEvent = point;
		},
		_completeGesture: function() {
			var self = this;
			self._lockAxis = true;
			self._hasMoved = self._isDragging = false;
			self._onDragRelease();
		},
		_onDragRelease:function(e, isThumbs) {
			var self = this,
				totalMoveDist,
				accDist,
				duration,
				v0,
				newPos,
				newDist,
				newDuration,
				blockLink;

			
			self.ev.trigger('rsDragRelease');


			self._renderMoveEvent = null;
			self._isDragging = false;
			self._lockAxis = false;
			self._checkedAxis = false;
			self._renderMoveTime = 0;
			cancelAnimationFrame(self._animFrame);
			if(self._hasMoved) {
				if(!isThumbs) {
					if(self._isMove) {
						self._setPosition(self._currRenderPosition);
					}
				} else {
					self._setThumbsPosition(self._currRenderPosition);
				}
			}

			self._doc.off(self._moveEvent).off(self._upEvent);

			if(self.hasTouch) {
				self._sliderOverflow.off(self._cancelEvent);	
			}

			
			self._setGrabCursor();
			if (!self._hasMoved && !self._multipleTouches) {
				if(isThumbs && self._thumbsEnabled) {
					var item = $(e.target).closest('.rsNavItem');
					if(item.length) {
						self.goTo(item.index());
					}	
					return;
				}
			}
			var orient = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal);
			if(!self._hasMoved || (self._currMoveAxis === 'y' && orient) || (self._currMoveAxis === 'x' && !orient) ) {
				return;
			}
			self.dragSuccess = true;
			
			self._currMoveAxis = '';

			
			function getCorrectSpeed(newSpeed) {
				if(newSpeed < 100) {
					return 100;
				} else if(newSpeed > 500) {
					return 500;
				} 
				return newSpeed;
			}
			function returnToCurrent(isSlow, v0) {
				if(self._isMove || isThumbs) {
					newPos = (-self._realId - self._idOffset) * self._slideSize;
					newDist = Math.abs(self._sPosition  - newPos);
					self._currAnimSpeed = newDist / v0;
					if(isSlow) {
						self._currAnimSpeed += 250; 
					}
					self._currAnimSpeed = getCorrectSpeed(self._currAnimSpeed);
					self._animateTo(newPos, false);
				}
			}

			var snapDist = self.st.minSlideOffset,
				point = self.hasTouch ? e.originalEvent.changedTouches[0] : e,
				pPos = orient ? point.pageX : point.pageY,
				sPos = self._startPagePos,
				axPos = self._accelerationPos,
				axCurrItem = self.currSlideId,
				axNumItems = self.numSlides,
				dir = orient ? self._horDir : self._verDir,
				loop = self._loop,
				changeHash = false,
				distOffset = 0;
			
			totalMoveDist = Math.abs(pPos - sPos);
			accDist = pPos - axPos;


			duration = (new Date().getTime()) - self._startTime;
			v0 = Math.abs(accDist) / duration;	

			if(dir === 0 || axNumItems <= 1) {
				returnToCurrent(true, v0);
				return;
			}

			if(!loop && !isThumbs) {
				if(axCurrItem <= 0) {
					if(dir > 0) {
						returnToCurrent(true, v0);
						return;
					}
				} else if(axCurrItem >= axNumItems - 1) {
					if(dir < 0) {
						returnToCurrent(true, v0);
						return;
					}
				}
			}

			if(!isThumbs) {
				if(sPos + snapDist < pPos) {
					if(dir < 0) {		
						returnToCurrent(false, v0);
						return;					
					}
					self._moveTo('prev', getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset + 1) * self._slideSize) / v0), changeHash, true, true);
				} else if(sPos - snapDist > pPos) {
					if(dir > 0) {		
						returnToCurrent(false, v0);
						return;					
					}
					self._moveTo('next', getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset - 1) * self._slideSize) / v0), changeHash, true, true);
				} else {
					returnToCurrent(false, v0);
				}
			} else {
				var newPos = self._thumbsPosition;
				var transitionSpeed;
				
				if(newPos > self._thumbsMinPosition) {
					newPos = self._thumbsMinPosition;
				} else if(newPos < self._thumbsMaxPosition) {
					newPos = self._thumbsMaxPosition;
				} else {
					var friction = 0.003,
						S = (v0 * v0) / (friction * 2),
						minXDist = -self._thumbsPosition,
						maxXDist = self._thumbsContainerSize - self._thumbsViewportSize + self._thumbsPosition;

					if (accDist > 0 && S > minXDist) {
						minXDist = minXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
						v0 = v0 * minXDist / S;
						S = minXDist;
					} else if (accDist < 0 && S > maxXDist) {
						maxXDist = maxXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
						v0 = v0 * maxXDist / S;
						S = maxXDist;
					}




					transitionSpeed =  Math.max(Math.round(v0 / friction), 50);
					newPos = newPos + S * (accDist < 0 ? -1 : 1);


					if(newPos > self._thumbsMinPosition) {
						self._animateThumbsTo(newPos, transitionSpeed, true, self._thumbsMinPosition, 200);
						return;
					 } else if(newPos < self._thumbsMaxPosition) {
						self._animateThumbsTo( newPos, transitionSpeed, true, self._thumbsMaxPosition, 200);
						return;
					}
				}

				self._animateThumbsTo(newPos, transitionSpeed, true);

			}
		},
		_setPosition: function(pos) {
			var self = this;
			pos = self._sPosition = pos;

			if(self._useCSS3Transitions) {
				self._slidesContainer.css(self._xProp, self._tPref1 + ( self._slidesHorizontal ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 );		
			} else {
				self._slidesContainer.css(self._slidesHorizontal ? self._xProp : self._yProp, pos);
			}
		},
		
		
		updateSliderSize: function(force) {
			var self = this,
				newWidth,
				newHeight;

			if (self.st.beforeResize) self.st.beforeResize.call(self);

			if(self.st.autoScaleSlider) {
				var asw = self.st.autoScaleSliderWidth,
					ash = self.st.autoScaleSliderHeight;

				if(self.st.autoScaleHeight) {
					newWidth = self.slider.width();
					if(newWidth != self.width) {
						self.slider.css("height", newWidth * (ash / asw) );
						newWidth = self.slider.width();
					}	
					newHeight = self.slider.height();
				} else {
					newHeight = self.slider.height();
					if(newHeight != self.height) {
						self.slider.css("width", newHeight * (asw / ash));
						newHeight = self.slider.height();
					}		
					newWidth = self.slider.width();
				}
			
			} else {
				newWidth = self.slider.width();
				newHeight = self.slider.height();
			}
			self._sliderOffset = self.slider.offset();
			self._sliderOffset = self._sliderOffset[self._reorderProp];


			if(force || newWidth != self.width || newHeight != self.height) {
				self.width = newWidth;
				self.height = newHeight;

				self._wrapWidth = newWidth;
				self._wrapHeight = newHeight;

				self.ev.trigger('rsBeforeSizeSet');
				
				self._sliderOverflow.css({
					width: self._wrapWidth,
					height: self._wrapHeight
				});


				self._slideSize = (self._slidesHorizontal ? self._wrapWidth : self._wrapHeight) + self.st.slidesSpacing;
				

				self._imagePadding = self.st.imageScalePadding;
				var item,
					slideItem,
					i,
					img;
				for(i = 0; i < self.slides.length; i++) {
					item = self.slides[i];
					item.positionSet = false;

					if(item && item.image && item.isLoaded) {
						item.isRendered = false;
						self._resizeImage(item);
					} 
				}
				if(self._cloneHolders) {
					for(i = 0; i < self._cloneHolders.length; i++) {
						item = self._cloneHolders[i];
						item.holder.css(self._reorderProp, (item.id + self._idOffset) * self._slideSize);

					}
				}
				
				self._updateBlocksContent();

				if(self._isMove) {
					if(self._useCSS3Transitions) {
						self._slidesContainer.css(self._vendorPref + 'transition-duration', '0s');
					}
					self._setPosition( (-self._realId - self._idOffset) * self._slideSize);
				}
				self.ev.trigger('rsOnUpdateNav');
				if (self.st.afterResize) self.st.afterResize.call(self);
			}



		},
		setSlidesOrientation: function(orient) {
			// TODO
			// var self = this,
			// 	newHor = Boolean(orient === 'horizontal');
			// if(self._slidesHorizontal !== newHor) {
			// 	self._setPosition(0);
			// 	if(self._isMove) {
			// 		for(var i = 0; i < self._slideHolders.length; i++) {
			// 			self._slideHolders[i].block.css(self._reorderProp, '');
			// 		}
			// 	}
			// 	self.slider.removeClass(self._slidesHorizontal ? 'rsHor' : 'rsVer').addClass(newHor ? 'rsHor' : 'rsVer');
			// 	self._slidesHorizontal = newHor;
			// 	self._reorderProp = newHor ? 'left' : 'top';
			// 	self.updateSliderSize(true);
			// }
		},
		/**
		 * Adds slide
		 * @param  {jQuery object or raw HTML} htmltext 
		 * @param  {int} index    (optional) Index where item should be added, last item removed of not specified
		 */
		appendSlide: function(htmltext, index) {
			var self = this,
				parsedSlide = self._parseNode(htmltext);

			if(isNaN(index) || index > self.numSlides) {
				index = self.numSlides;
			}
			self.slides.splice(index, 0, parsedSlide);
			self.slidesJQ.splice(index, 0, '<div style="'+ (self._isMove ? 'position: absolute;' : 'z-index: 0; display:none; opacity: 0; position: absolute;  left: 0; top: 0;' ) +'" class="rsSlide"></div>');

			if(index < self.currSlideId) {
				self.currSlideId++;
			}
			self.ev.trigger('rsOnAppendSlide', [parsedSlide, index]);
			
			self._refreshSlides(index);

			if(index === self.currSlideId) {
				self.ev.trigger('rsAfterSlideChange');
			}
		},

		/**
		 * Removes slide
		 * @param  {int} index Index of item that should be removed
		 */
		removeSlide: function(index) {
			var self = this,
				slideToRemove = self.slides[index];

			if(slideToRemove) {
				if(slideToRemove.holder) {
					slideToRemove.holder.remove();
				}
				if(index < self.currSlideId) {
					self.currSlideId++;
				}
				self.slides.splice(index, 1);
				self.slidesJQ.splice(index, 1);

				self.ev.trigger('rsOnRemoveSlide', [index]);
				self._refreshSlides(index);

				if(index === self.currSlideId) {
					self.ev.trigger('rsAfterSlideChange');
				}
			}
		},
		_refreshSlides: function(refreshIndex) {

			// todo: optimize this stuff
			var self = this;

			var oldNumSlides = self.numSlides;
			var numLoops = self._realId <= 0 ? 0 : Math.floor(self._realId / oldNumSlides);

			self.numSlides = self.slides.length;
			if(self.numSlides === 0) {
				self.currSlideId = self._idOffset = self._realId = 0;
				self.currSlide = self._oldHolder = null;
			} else {
				self._realId = numLoops * self.numSlides + self.currSlideId;
			}

			for(var i = 0; i < self.numSlides; i++) {
				self.slides[i].id = i;
			}

			self.currSlide = self.slides[self.currSlideId];
			self._currHolder = self.slidesJQ[self.currSlideId];

			if(self.currSlideId >= self.numSlides) {
				self.goTo(self.numSlides - 1);
			} else if(self.currSlideId < 0) {
				self.goTo(0);
			}

			self._refreshNumPreloadImages();

			if(self._isMove && self._loop) {
				self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
			}
			if(self._refreshSlidesTimeout) {
				clearTimeout(self._refreshSlidesTimeout);
			}
			self._refreshSlidesTimeout = setTimeout(function() {
				self._setPosition( (-self._realId - self._idOffset) * self._slideSize);	
				self._updateBlocksContent();
			}, 14);
			self.ev.trigger('rsOnUpdateNav');
		},
		_setGrabCursor:function() {	
			var self = this;
			if(!self.hasTouch && self._isMove) {
				if(self._grabCursor) {
					self._sliderOverflow.css('cursor', self._grabCursor);
				} else {
					self._sliderOverflow.removeClass('grabbing-cursor');
					self._sliderOverflow.addClass('grab-cursor');	
				}
			}
		},
		_setGrabbingCursor:function() {		
			var self = this;
			if(!self.hasTouch && self._isMove) {
				if(self._grabbingCursor) {
					self._sliderOverflow.css('cursor', self._grabbingCursor);
				} else {
					self._sliderOverflow.removeClass('grab-cursor');
					self._sliderOverflow.addClass('grabbing-cursor');	
				}	
			}
		},
		next: function(notUserAction) {
			var self = this;
			self._moveTo('next',  self.st.transitionSpeed, true, !notUserAction);
		},
		prev: function(notUserAction) {
			var self = this;
			self._moveTo('prev', self.st.transitionSpeed, true, !notUserAction);
		},
		_moveTo:function(type,  speed, inOutEasing, userAction, fromSwipe) {
			var self = this,
				newPos,
				difference,
				i;


			// if(self._isWorking) {
			// 	return;
			// }

			if(self._isVideoPlaying) {
				self.stopVideo();
			}
			self.ev.trigger('rsBeforeMove', [type, userAction]);
			if(type === 'next') {
				newItemId = self.currSlideId+1;
			} else if(type === 'prev') {
				newItemId = self.currSlideId-1;
			} else {
				newItemId = type = parseInt(type, 10);
			}

			if(!self._loop) {
				if(newItemId < 0) {
					self._doBackAndForthAnim('left', !userAction);
					return;
				} else if(newItemId >= self.numSlides ) {
					self._doBackAndForthAnim('right', !userAction);
					return;
				}
			}
			
			if(self._isAnimating) {
				self._stopAnimation();
				inOutEasing = false;
			}

			difference = newItemId - self.currSlideId;



			self._prevSlideId = self.currSlideId;
			var prevId = self.currSlideId;
			var id = self.currSlideId + difference;
			var realId = self._realId;
			var temp;
			var delayed;
			if(self._loop) {
				id = self._updateBlocksContent(false, id);
				realId += difference;
			} else {
				realId = id;
			}
			self._newSlideId = id;

			self._oldHolder = self.slidesJQ[self.currSlideId];

			
			self._realId = realId;
			self.currSlideId = self._newSlideId;

			self.currSlide = self.slides[self.currSlideId];
			self._currHolder = self.slidesJQ[self.currSlideId];

			
			var checkDist = 2;
			var next = Boolean(difference > 0);
			var absDiff = Math.abs(difference);
			var g1 = Math.floor( prevId / self._numPreloadImages);
			var g2 = Math.floor( ( prevId + (next ? checkDist : -checkDist  ) ) / self._numPreloadImages);
			var biggest = next ? Math.max(g1,g2) : Math.min(g1,g2);
			var biggestId = biggest * self._numPreloadImages +  ( next ? (self._numPreloadImages - 1) : 0 );
			if(biggestId > self.numSlides - 1) {
				biggestId = self.numSlides - 1;
			} else if(biggestId < 0) {
				biggestId = 0;
			}
			var toLast =  next ? (biggestId - prevId) :  (prevId - biggestId);
			if(toLast > self._numPreloadImages) {
				toLast = self._numPreloadImages;
			}
			if(absDiff > toLast + checkDist) {
				self._idOffset +=  ( absDiff - (toLast + checkDist) ) * ( next ? -1 : 1 );
				speed = speed * 1.4;
				for(i = 0; i < self.numSlides; i++) {
					self.slides[i].positionSet = false;
				}
			}
			self._currAnimSpeed = speed;

			self._updateBlocksContent(true);
			if(!fromSwipe) {
				
				delayed = true;
			}

			// if(self._isMove && self._loop && ( self._realId < 0 || self._realId >= self.numSlides ) ) {
			// 	self._isWorking = true;
			// }


			newPos = (-realId - self._idOffset) * self._slideSize;

			

			if(delayed) {
				//self._isWorking = true;
				setTimeout(function() {
					self._isWorking = false;
					self._animateTo(newPos, type, false, inOutEasing);
					self.ev.trigger('rsOnUpdateNav');
				}, 0);
			} else {
				self._animateTo(newPos, type, false, inOutEasing);
				self.ev.trigger('rsOnUpdateNav');
			}
			
			
			function isSetToCurrent(testId) {
				if(testId < 0) {
					testId = self.numSlides + testId;
				} else if(testId > self.numSlides - 1) {
					testId = testId - self.numSlides;
				}
				if(testId !== self.currSlideId) {
					return false;
				}
				return true;
			}
			
		},
		_updateArrowsNav: function() {
			var self = this,
				arrDisClass = 'rsArrowDisabled';
			if(self.st.arrowsNav) {
				if(self.numSlides <= 1) {
					self._arrowLeft.css('display', 'none');
					self._arrowRight.css('display', 'none');
					return;
				} else {
					self._arrowLeft.css('display', 'block');
					self._arrowRight.css('display', 'block');
				}
				if(!self._loop && !self.st.loopRewind) {
					if(self.currSlideId === 0) {
						self._arrowLeft.addClass(arrDisClass);
					} else {
						self._arrowLeft.removeClass(arrDisClass);
					}
					if(self.currSlideId === self.numSlides - 1) {
						self._arrowRight.addClass(arrDisClass);
					} else {
						self._arrowRight.removeClass(arrDisClass);
					}
				}
			}
		},
		_animateTo:function(pos, dir,  loadAll, inOutEasing, customComplete) {
			var self = this,
				moveProp,
				oldBlock,
				animBlock;

			var animObj = {};
			if(isNaN(self._currAnimSpeed)) {
				self._currAnimSpeed = 400;
			} 
			

			self._sPosition = self._currRenderPosition = pos;

			self.ev.trigger('rsBeforeAnimStart');
			if (self.st.beforeSlideChange) self.st.beforeSlideChange.call(self);

			if(!self._useCSS3Transitions) {
				if(self._isMove) {
					animObj[self._slidesHorizontal ? self._xProp : self._yProp] = pos + 'px';


					self._slidesContainer.animate(animObj, self._currAnimSpeed, /*'easeOutQuart'*/ inOutEasing ? self.st.easeInOut : self.st.easeOut);
				} else {
					oldBlock = self._oldHolder;
					animBlock = self._currHolder;					

					animBlock.stop(true, true).css({
						opacity: 0,
						display: 'block',
						zIndex: self._fadeZIndex
					});
					self._currAnimSpeed = self.st.transitionSpeed;
					animBlock.animate({opacity: 1}, self._currAnimSpeed, self.st.easeInOut);

					
					clearTimeouts();
					if(oldBlock) {
	 					oldBlock.data('rsTimeout', setTimeout(function() {
							oldBlock.stop(true, true).css({
								opacity: 0,
								display: 'none',
								zIndex: 0
							});
						}, self._currAnimSpeed + 60) );
					}
				}
				
			} else {
				if(self._isMove) {
					
						animObj[(self._vendorPref + self._TD)] = self._currAnimSpeed+'ms';
						animObj[(self._vendorPref + self._TTF)] = inOutEasing ? $.rsCSS3Easing[self.st.easeInOut] : $.rsCSS3Easing[self.st.easeOut];
						
						self._slidesContainer.css(animObj);
					
					setTimeout(function() {
						self._setPosition(pos);
					}, self.hasTouch ? 5 : 0);
					

				} else {
					//self._currAnimSpeed = 10
					self._currAnimSpeed = self.st.transitionSpeed;
					oldBlock = self._oldHolder;
					animBlock = self._currHolder;		
					if(animBlock.data('rsTimeout')) {
						animBlock.css('opacity', 0);
					}
					clearTimeouts();
					if(oldBlock) {
						//if(oldBlock)
						oldBlock.data('rsTimeout', setTimeout(function() {
							animObj[self._vendorPref + self._TD] = '0ms';
							animObj.zIndex = 0;
							animObj.display = 'none';
							oldBlock.data('rsTimeout', '');
							oldBlock.css(animObj);
							setTimeout(function() {
								oldBlock.css('opacity', 0);
							}, 16);
						}, self._currAnimSpeed + 60) );
					}

					animObj.display = 'block';
					animObj.zIndex = self._fadeZIndex;
					animObj.opacity = 0;
					animObj[self._vendorPref + self._TD] = '0ms';
					animObj[self._vendorPref + self._TTF] = $.rsCSS3Easing[self.st.easeInOut];
					animBlock.css(animObj);
					animBlock.data('rsTimeout', setTimeout(function() {
						//animBlock.css('opacity', 0);
						animBlock.css(self._vendorPref + self._TD,  self._currAnimSpeed+'ms');

						//oldBlock.css(self._vendorPref + self._TD,  '0ms');
						animBlock.data('rsTimeout', setTimeout(function() {
							animBlock.css('opacity', 1);
							animBlock.data('rsTimeout', '');
						}, 20) );
					}, 20) );
				}
			}
			self._isAnimating = true;
			if(self.loadingTimeout) {
				clearTimeout(self.loadingTimeout);
			}
			if(customComplete) {
				self.loadingTimeout = setTimeout(function() {
					self.loadingTimeout = null;
					customComplete.call();

				}, self._currAnimSpeed + 60);
			} else {
				self.loadingTimeout = setTimeout(function() {
					self.loadingTimeout = null;
					self._animationComplete(dir);
				}, self._currAnimSpeed + 60);
			}

			function clearTimeouts() {
				var t = oldBlock.data('rsTimeout');
				if(t) {
					if(oldBlock !== animBlock) {
						oldBlock.css({
								opacity: 0,
								display: 'none',
								zIndex: 0
							});
					}
					clearTimeout(t);
					oldBlock.data('rsTimeout', '');
				}
				t = animBlock.data('rsTimeout');
				if(t) {
					clearTimeout(t);
					animBlock.data('rsTimeout', '');
				}
			}
		},
		_stopAnimation: function() {
			var self = this;
			self._isAnimating = false;
			clearTimeout(self.loadingTimeout);
			if(self._isMove) {
				if(!self._useCSS3Transitions) {
					self._slidesContainer.stop(true);
					self._sPosition = parseInt(self._slidesContainer.css(self._xProp), 10);
				} else {
					var oldPos = self._sPosition;
					var newPos =  self._currRenderPosition = self._getTransformProp();

					self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
					if(oldPos !==newPos) {
						self._setPosition(newPos);
					}
				}
			} else {
				// kung fu
				if(self._fadeZIndex > 20) {
					self._fadeZIndex = 10;
				} else {
					self._fadeZIndex++;
				}
			}
			
			
		},
		// Thanks to @benpbarnett
		_getTransformProp:function(){
			var self = this,
				transform = window.getComputedStyle(self._slidesContainer.get(0), null).getPropertyValue(self._vendorPref + 'transform'),			
				explodedMatrix = transform.replace(/^matrix\(/i, '').split(/, |\)$/g);		
			return parseInt(explodedMatrix[(self._slidesHorizontal ? 4 : 5)], 10);
		},
		_getCSS3Prop: function(pos, hor) {
			var self = this;
			return self._useCSS3Transitions ? self._tPref1 + ( hor ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 : pos;
		},
		_animationComplete: function(dir) {
			var self = this;
			if(!self._isMove) {
				self._currHolder.css('z-index', 0);
				self._fadeZIndex = 10;
			}
			self._isAnimating = false;
			
			self.staticSlideId = self.currSlideId;
			self._updateBlocksContent();


			self._slidesMoved = false;
			
			self.ev.trigger('rsAfterSlideChange');

			if (self.st.afterSlideChange) self.st.afterSlideChange.call(self);
		},
		_doBackAndForthAnim:function(type, userAction) {
			var self = this,
				newPos = (-self._realId - self._idOffset) * self._slideSize;
				moveDist = 30;

			if(self.numSlides === 0) {
				return;
			} 
			if(self.st.loopRewind) {
				if(type === 'left') {
					self.goTo(self.numSlides - 1, userAction);
				} else {

					self.goTo(0, userAction);
				}
				return;
			}


			if(self._isAnimating) {
				return;
			}

			if(self._isMove) {
				if(moveDist !== 0) {
					self._currAnimSpeed = 200;

					function allAnimComplete() {
						self._isAnimating = false;
					}
					function firstAnimComplete() {
						self._isAnimating = false;
						self._animateTo(newPos, '', false, true, allAnimComplete);
					}
					self._animateTo(newPos + (type === 'left' ? moveDist : -moveDist),'', false, true, firstAnimComplete);
				}
			}
			
		},
		_resizeImage:function(slideObject, useClone) {

			var isRoot = true;
			if(slideObject.isRendered) {
				return;
			}
			var img = slideObject.content;
			var classToFind = 'rsImg';
			var isVideo;
			var self = this,
				imgAlignCenter = self.st.imageAlignCenter,
				imgScaleMode = self.st.imageScaleMode,
				tempEl;

			if(slideObject.videoURL) {
				classToFind = 'rsVideoContainer';
				if(imgScaleMode !== 'fill') {
					isVideo = true;
				} else {
					tempEl = img;
					if(!tempEl.hasClass(classToFind)) {
						tempEl = tempEl.find('.'+classToFind);
					}
					tempEl.css({width:'100%',height: '100%'});
					classToFind = 'rsImg';
				}
			}
			if(!img.hasClass(classToFind)) {
				isRoot = false;
				img = img.find('.'+classToFind);
			}

			var baseImageWidth = slideObject.iW,
				baseImageHeight = slideObject.iH;

			slideObject.isRendered = true;


			if(imgScaleMode === 'none' && !imgAlignCenter) {
				return;
			}

			if(imgScaleMode !== 'fill') {
				bMargin = self._imagePadding;
			} else {
				bMargin = 0;
			}
			//var block = img.parent('.block-inside').css('margin', bMargin);
			var containerWidth = self._wrapWidth - bMargin * 2,
				containerHeight = self._wrapHeight - bMargin * 2,
				hRatio,
				vRatio,
				ratio,
				nWidth,
				nHeight,
				cssObj = {};

			if(imgScaleMode === 'fit-if-smaller') {
				if(baseImageWidth > containerWidth || baseImageHeight > containerHeight) {
					imgScaleMode = 'fit';
				}
			}
			if(imgScaleMode === 'fill' || imgScaleMode === 'fit') {		
				hRatio = containerWidth / baseImageWidth;
				vRatio = containerHeight / baseImageHeight;

				if (imgScaleMode  == "fill") {
					ratio = hRatio > vRatio ? hRatio : vRatio;                    			
				} else if (imgScaleMode  == "fit") {
					ratio = hRatio < vRatio ? hRatio : vRatio;             		   	
				} else {
					ratio = 1;
				}

				nWidth = Math.ceil(baseImageWidth * ratio, 10);
				nHeight = Math.ceil(baseImageHeight * ratio, 10);
			} else {								
				nWidth = baseImageWidth;
				nHeight = baseImageHeight;		
			}
			if(imgScaleMode !== 'none') {
				cssObj.width = nWidth;
				cssObj.height = nHeight;
				if(isVideo) {
					img.find('.rsImg').css({width: '100%', height:'100%'});
				}
			}
			if (imgAlignCenter) {     
				cssObj.marginLeft = Math.floor((containerWidth - nWidth) / 2) +  bMargin; //cssObj.marginLeft = Math.floor((containerWidth - nWidth) / 2) +  bMargin;
				cssObj.marginTop = Math.floor((containerHeight - nHeight) / 2) +  bMargin; //cssObj.marginTop = Math.floor((containerHeight - nHeight) / 2) +  bMargin;
			}
			img.css(cssObj);
		}
	}; /* RoyalSlider core prototype end */
	$.rsProto = RoyalSlider.prototype;

	$.fn.royalSlider = function(options) {    	
		var args = arguments;
		return this.each(function(){
			var self = $(this);
			if (typeof options === "object" ||  !options) {
				if( !self.data('royalSlider') ) {
					self.data('royalSlider', new RoyalSlider(self, options));
				}
			} else {
				var royalSlider = self.data('royalSlider');
				if (royalSlider && royalSlider[options]) {
					return royalSlider[options].apply(royalSlider, Array.prototype.slice.call(args, 1));
				}
			}
		});
	};

	$.fn.royalSlider.defaults = {    
		slidesSpacing: 8,
		startSlideId: 0,
		loop: false,
		loopRewind: false,
		numImagesToPreload: 4,
		fadeinLoadedSlide: true,
		slidesOrientation: 'horizontal', 
		transitionType: 'move', 
		transitionSpeed: 600,
		controlNavigation: 'bullets',
		controlsInside: true, 
		arrowsNav: true,
		arrowsNavAutoHide: true,
		navigateByClick: true,
		randomizeSlides: false,
		sliderDrag: true, 
		sliderTouch: true,
		keyboardNavEnabled: false,
		fadeInAfterLoaded: true,

		allowCSS3: true,
		allowCSS3OnWebkit: true,

		
		addActiveClass: false,
		autoHeight: false,

		easeOut: 'easeOutSine',
		easeInOut: 'easeInOutSine',

		minSlideOffset: 10,

		imageScaleMode:"fit-if-smaller",                 
		imageAlignCenter:true,				
		imageScalePadding: 4,

		autoScaleSlider: false,               
   					
   		autoScaleSliderWidth: 800,       
   		autoScaleSliderHeight: 400,   

   		autoScaleHeight: true,	    

   		arrowsNavHideOnTouch: false,
   		globalCaption: false,

   		// deprecated callbacks
   		beforeSlideChange: null,     
		afterSlideChange: null,       
		beforeResize: null,			
		afterResize: null			
	}; /* default options end */

	$.rsCSS3Easing = {
		easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
		easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
	};

	$.extend(jQuery.easing, {
		easeInOutSine: function (x, t, b, c, d) {
			return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
		},
		easeOutSine: function (x, t, b, c, d) {
			return c * Math.sin(t/d * (Math.PI/2)) + b;
		},
		easeOutCubic: function (x, t, b, c, d) {
			return c*((t=t/d-1)*t*t + 1) + b;
		}
	});

})(jQuery);
/*!
 * ColorBox v1.3.19 - jQuery lightbox plugin; (c) 2011 Jack Moore - jacklmoore.com
 * License: http://www.opensource.org/licenses/mit-license.php
 */
(function ($, document, window) {
	var
	// Default settings object.
	// See http://jacklmoore.com/colorbox for details.
	defaults = {
		transition : "elastic",
		speed : 300,
		width : false,
		initialWidth : "600",
		innerWidth : false,
		maxWidth : 600,
		height : false,
		initialHeight : "300",
		innerHeight : false,
		maxHeight : false,
		scalePhotos : true,
		scrolling : true,
		inline : false,
		html : false,
		iframe : false,
		fastIframe : true,
		photo : false,
		href : false,
		title : false,
		rel : false,
		opacity : 0.9,
		preloading : true,
		current : "image {current} of {total}",
		previous : "previous",
		next : "next",
		close : "close",
		open : false,
		returnFocus : true,
		reposition : true,
		loop : true,
		slideshow : false,
		slideshowAuto : true,
		slideshowSpeed : 2500,
		slideshowStart : "start slideshow",
		slideshowStop : "stop slideshow",
		onOpen : false,
		onLoad : false,
		onComplete : false,
		onCleanup : false,
		onClosed : false,
		overlayClose : true,
		escKey : true,
		arrowKey : true,
		top : false,
		bottom : false,
		left : false,
		right : false,
		fixed : false,
		data : undefined
	},

	// Abstracting the HTML and event identifiers for easy rebranding
	colorbox = 'colorbox', prefix = 'cbox', boxElement = prefix + 'Element',

	// Events
	event_open = prefix + '_open', event_load = prefix + '_load', event_complete = prefix + '_complete', event_cleanup = prefix + '_cleanup', event_closed = prefix + '_closed', event_purge = prefix + '_purge',

	// Special Handling for IE
	isIE = !$.support.opacity && !$.support.style, // IE7 & IE8
	isIE6 = isIE && !window.XMLHttpRequest, // IE6
	event_ie6 = prefix + '_IE6',

	// Cached jQuery Object Variables
	$overlay, $box, $wrap, $content, $topBorder, $leftBorder, $rightBorder, $bottomBorder, $related, $window, $loaded, $loadingBay, $loadingOverlay, $title, $current, $slideshow, $next, $prev, $close, $groupControls,

	// Variables for cached values or use across multiple functions
	settings, interfaceHeight, interfaceWidth, loadedHeight, loadedWidth, element, index, photo, open, active, closing, loadingTimer, publicMethod, div = "div", init;

	// ****************
	// HELPER FUNCTIONS
	// ****************

	// Convience function for creating new jQuery objects
	function $tag(tag, id, css) {
		var element = document.createElement(tag);

		if(id) {
			element.id = prefix + id;
		}

		if(css) {
			element.style.cssText = css;
		}

		return $(element);
	}

	// Determine the next and previous members in a group.
	function getIndex(increment) {
		var max = $related.length, newIndex = (index + increment) % max;

		return (newIndex < 0) ? max + newIndex : newIndex;
	}

	// Convert '%' and 'px' values to integers
	function setSize(size, dimension) {
		return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : $window.height()) / 100) : 1) * parseInt(size, 10));
	}

	// Checks an href to see if it is a photo.
	// There is a force photo option (photo: true) for hrefs that cannot be matched by this regex.
	function isImage(url) {
		return settings.photo || /\.(gif|png|jpe?g|bmp|ico)((#|\?).*)?$/i.test(url);
	}

	// Assigns function results to their respective properties
	function makeSettings() {
		var i;
		settings = $.extend({}, $.data(element, colorbox));

		for(i in settings) {
			if($.isFunction(settings[i]) && i.slice(0, 2) !== 'on') {// checks to make sure the function isn't one of the callbacks, they will be handled at the appropriate time.
				settings[i] = settings[i].call(element);
			}
		}

		settings.rel = settings.rel || element.rel || 'nofollow';
		settings.href = settings.href || $(element).attr('href');
		settings.title = settings.title || element.title;

		if( typeof settings.href === "string") {
			settings.href = $.trim(settings.href);
		}
	}

	function trigger(event, callback) {
		$.event.trigger(event);
		if(callback) {
			callback.call(element);
		}
	}

	// Slideshow functionality
	function slideshow() {
		var timeOut, className = prefix + "Slideshow_", click = "click." + prefix, start, stop, clear;

		if(settings.slideshow && $related[1]) {
			start = function() {
				$slideshow.text(settings.slideshowStop).unbind(click).bind(event_complete, function() {
					if(settings.loop || $related[index + 1]) {
						timeOut = setTimeout(publicMethod.next, settings.slideshowSpeed);
					}
				}).bind(event_load, function() {
					clearTimeout(timeOut);
				}).one(click + ' ' + event_cleanup, stop);
				$box.removeClass(className + "off").addClass(className + "on");
				timeOut = setTimeout(publicMethod.next, settings.slideshowSpeed);
			};
			stop = function() {
				clearTimeout(timeOut);
				$slideshow.text(settings.slideshowStart).unbind([event_complete, event_load, event_cleanup, click].join(' ')).one(click, function() {
					publicMethod.next();
					start();
				});
				$box.removeClass(className + "on").addClass(className + "off");
			};
			if(settings.slideshowAuto) {
				start();
			} else {
				stop();
			}
		} else {
			$box.removeClass(className + "off " + className + "on");
		}
	}

	function launch(target) {
		if(!closing) {
			element = target;

			makeSettings();
			$related = $(element);
			index = 0;

			if(settings.rel !== 'nofollow') {
				$related = $('.' + boxElement).filter(function() {
					var relRelated = $.data(this, colorbox).rel || this.rel;
					return (relRelated === settings.rel);
				});
				index = $related.index(element);

				// Check direct calls to ColorBox.
				if(index === -1) {
					$related = $related.add(element);
					index = $related.length - 1;
				}
			}

			if(!open) {
				open = active = true;
				// Prevents the page-change action from queuing up if the visitor holds down the left or right keys.

				$box.show();

				if(settings.returnFocus) {
					$(element).blur().one(event_closed, function() {
						$(this).focus();
					});
				}

				// +settings.opacity avoids a problem in IE when using non-zero-prefixed-string-values, like '.5'
				$overlay.css({
					"opacity" : +settings.opacity,
					"cursor" : settings.overlayClose ? "pointer" : "auto"
				}).show();

				// Opens inital empty ColorBox prior to content being loaded.
				settings.w = setSize(settings.initialWidth, 'x');
				settings.h = setSize(settings.initialHeight, 'y');
				publicMethod.position();

				if(isIE6) {
					$window.bind('resize.' + event_ie6 + ' scroll.' + event_ie6, function() {
						$overlay.css({
							width : $window.width(),
							height : $window.height(),
							top : $window.scrollTop(),
							left : $window.scrollLeft()
						});
					}).trigger('resize.' + event_ie6);
				}

				trigger(event_open, settings.onOpen);

				$groupControls.add($title).hide();

				$close.html(settings.close).show();
			}

			publicMethod.load(true);
		}
	}

	// ColorBox's markup needs to be added to the DOM prior to being called
	// so that the browser will go ahead and load the CSS background images.
	function appendHTML() {
		if(!$box && document.body) {
			init = false;
			$window = $(window);
			$box = $tag(div).attr({
				id : colorbox,
				'class' : isIE ? prefix + ( isIE6 ? 'IE6' : 'IE') : ''
			}).hide();
			$overlay = $tag(div, "Overlay", isIE6 ? 'position:absolute' : '').hide();
			$wrap = $tag(div, "Wrapper");
			$content = $tag(div, "Content").append( $loaded = $tag(div, "LoadedContent", 'width:0; height:0; overflow:hidden'), $loadingOverlay = $tag(div, "LoadingOverlay").add($tag(div, "LoadingGraphic")), $title = $tag(div, "Title"), $current = $tag(div, "Current"), $next = $tag(div, "Next"), $prev = $tag(div, "Previous"), $slideshow = $tag(div, "Slideshow").bind(event_open, slideshow), $close = $tag(div, "Close"));

			$wrap.append(// The 3x3 Grid that makes up ColorBox
			$tag(div).append($tag(div, "TopLeft"), $topBorder = $tag(div, "TopCenter"), $tag(div, "TopRight")), $tag(div, false, 'clear:left').append( $leftBorder = $tag(div, "MiddleLeft"), $content, $rightBorder = $tag(div, "MiddleRight")), $tag(div, false, 'clear:left').append($tag(div, "BottomLeft"), $bottomBorder = $tag(div, "BottomCenter"), $tag(div, "BottomRight"))).find('div div').css({
				'float' : 'left'
			});
			$loadingBay = $tag(div, false, 'position:absolute; width:9999px; visibility:hidden; display:none');
			$groupControls = $next.add($prev).add($current).add($slideshow);

			$(document.body).append($overlay, $box.append($wrap, $loadingBay));
		}
	}

	// Add ColorBox's event bindings
	function addBindings() {
		if($box) {
			if(!init) {
				init = true;

				// Cache values needed for size calculations
				interfaceHeight = $topBorder.height() + $bottomBorder.height() + $content.outerHeight(true) - $content.height();
				//Subtraction needed for IE6
				interfaceWidth = $leftBorder.width() + $rightBorder.width() + $content.outerWidth(true) - $content.width();
				loadedHeight = $loaded.outerHeight(true);
				loadedWidth = $loaded.outerWidth(true);

				// Setting padding to remove the need to do size conversions during the animation step.
				$box.css({
					"padding-bottom" : interfaceHeight,
					"padding-right" : interfaceWidth
				});

				// Anonymous functions here keep the public method from being cached, thereby allowing them to be redefined on the fly.
				$next.click(function() {
					publicMethod.next();
				});
				$prev.click(function() {
					publicMethod.prev();
				});
				$close.click(function() {
					publicMethod.close();
				});
				$overlay.click(function() {
					if(settings.overlayClose) {
						publicMethod.close();
					}
				});
				// Key Bindings
				$(document).bind('keydown.' + prefix, function(e) {
					var key = e.keyCode;
					if(open && settings.escKey && key === 27) {
						e.preventDefault();
						publicMethod.close();
					}
					if(open && settings.arrowKey && $related[1]) {
						if(key === 37) {
							e.preventDefault();
							$prev.click();
						} else if(key === 39) {
							e.preventDefault();
							$next.click();
						}
					}
				});

				$('.' + boxElement, document).live('click', function(e) {
					// ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.
					// See: http://jacklmoore.com/notes/click-events/
					if(!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey)) {
						e.preventDefault();
						launch(this);
					}
				});
			}
			return true;
		}
		return false;
	}

	// Don't do anything if ColorBox already exists.
	if($.colorbox) {
		return;
	}

	// Append the HTML when the DOM loads
	$(appendHTML);

	// ****************
	// PUBLIC FUNCTIONS
	// Usage format: $.fn.colorbox.close();
	// Usage from within an iframe: parent.$.fn.colorbox.close();
	// ****************

	publicMethod = $.fn[colorbox] = $[colorbox] = function(options, callback) {
		var $this = this;
		options = options || {};

		appendHTML();

		if(addBindings()) {
			if(!$this[0]) {
				if($this.selector) {// if a selector was given and it didn't match any elements, go ahead and exit.
					return $this;
				}
				// if no selector was given (ie. $.colorbox()), create a temporary element to work with
				$this = $('<a/>');
				options.open = true;
				// assume an immediate open
			}

			if(callback) {
				options.onComplete = callback;
			}

			$this.each(function() {
				$.data(this, colorbox, $.extend({}, $.data(this, colorbox) || defaults, options));
			}).addClass(boxElement);

			if(($.isFunction(options.open) && options.open.call($this)) || options.open) {
				launch($this[0]);
			}
		}

		return $this;
	};

	publicMethod.position = function(speed, loadedCallback) {
		var top = 0, left = 0, offset = $box.offset(), scrollTop = $window.scrollTop(), scrollLeft = $window.scrollLeft();

		$window.unbind('resize.' + prefix);

		// remove the modal so that it doesn't influence the document width/height
		$box.css({
			top : -9e4,
			left : -9e4
		});

		if(settings.fixed && !isIE6) {
			offset.top -= scrollTop;
			offset.left -= scrollLeft;
			$box.css({
				position : 'fixed'
			});
		} else {
			top = scrollTop;
			left = scrollLeft;
			$box.css({
				position : 'absolute'
			});
		}

		// keeps the top and left positions within the browser's viewport.
		if(settings.right !== false) {
			left += Math.max($window.width() - settings.w - loadedWidth - interfaceWidth - setSize(settings.right, 'x'), 0);
		} else if(settings.left !== false) {
			left += setSize(settings.left, 'x');
		} else {
			left += Math.round(Math.max($window.width() - settings.w - loadedWidth - interfaceWidth, 0) / 2);
		}

		if(settings.bottom !== false) {
			top += Math.max($window.height() - settings.h - loadedHeight - interfaceHeight - setSize(settings.bottom, 'y'), 0);
		} else if(settings.top !== false) {
			top += setSize(settings.top, 'y');
		} else {
			top += Math.round(Math.max($window.height() - settings.h - loadedHeight - interfaceHeight, 0) / 2);
		}

		$box.css({
			top : offset.top,
			left : offset.left
		});

		// setting the speed to 0 to reduce the delay between same-sized content.
		speed = ($box.width() === settings.w + loadedWidth && $box.height() === settings.h + loadedHeight) ? 0 : speed || 0;

		// this gives the wrapper plenty of breathing room so it's floated contents can move around smoothly,
		// but it has to be shrank down around the size of div#colorbox when it's done.  If not,
		// it can invoke an obscure IE bug when using iframes.
		$wrap[0].style.width = $wrap[0].style.height = "9999px";

		function modalDimensions(that) {
			$topBorder[0].style.width = $bottomBorder[0].style.width = $content[0].style.width = that.style.width;
			$content[0].style.height = $leftBorder[0].style.height = $rightBorder[0].style.height = that.style.height;
		}


		$box.dequeue().animate({
			width : settings.w + loadedWidth,
			height : settings.h + loadedHeight,
			top : top,
			left : left
		}, {
			duration : speed,
			complete : function() {
				modalDimensions(this);
				active = false;

				// shrink the wrapper down to exactly the size of colorbox to avoid a bug in IE's iframe implementation.
				$wrap[0].style.width = (settings.w + loadedWidth + interfaceWidth) + "px";
				$wrap[0].style.height = (settings.h + loadedHeight + interfaceHeight) + "px";

				if(settings.reposition) {
					setTimeout(function() {// small delay before binding onresize due to an IE8 bug.
						$window.bind('resize.' + prefix, publicMethod.position);
					}, 1);
				}

				if(loadedCallback) {
					loadedCallback();
				}
			},
			step : function() {
				modalDimensions(this);
			}
		});
	};

	publicMethod.resize = function(options) {
		if(open) {
			options = options || {};

			if(options.width) {
				settings.w = setSize(options.width, 'x') - loadedWidth - interfaceWidth;
			}
			if(options.innerWidth) {
				settings.w = setSize(options.innerWidth, 'x');
			}
			$loaded.css({
				width : settings.w
			});

			if(options.height) {
				settings.h = setSize(options.height, 'y') - loadedHeight - interfaceHeight;
			}
			if(options.innerHeight) {
				settings.h = setSize(options.innerHeight, 'y');
			}
			if(!options.innerHeight && !options.height) {
				$loaded.css({
					height : "auto"
				});
				settings.h = $loaded.height();
			}
			$loaded.css({
				height : settings.h
			});

			publicMethod.position(settings.transition === "none" ? 0 : settings.speed);
		}
	};

	publicMethod.prep = function(object) {
		if(!open) {
			return;
		}

		var callback, speed = settings.transition === "none" ? 0 : settings.speed;

		$loaded.remove();
		$loaded = $tag(div, 'LoadedContent').append(object);

		function getWidth() {
			settings.w = settings.w || $loaded.width();
			settings.w = settings.mw && settings.mw < settings.w ? settings.mw : settings.w;
			return settings.w;
		}

		function getHeight() {
			settings.h = settings.h || $loaded.height();
			settings.h = settings.mh && settings.mh < settings.h ? settings.mh : settings.h;
			return settings.h;
		}


		$loaded.hide().appendTo($loadingBay.show())// content has to be appended to the DOM for accurate size calculations.
		.css({
			width : getWidth(),
			overflow : settings.scrolling ? 'auto' : 'hidden'
		}).css({
			height : getHeight()
		})// sets the height independently from the width in case the new width influences the value of height.
		.prependTo($content);

		$loadingBay.hide();

		// floating the IMG removes the bottom line-height and fixed a problem where IE miscalculates the width of the parent element as 100% of the document width.
		//$(photo).css({'float': 'none', marginLeft: 'auto', marginRight: 'auto'});

		$(photo).css({
			'float' : 'none'
		});

		// Hides SELECT elements in IE6 because they would otherwise sit on top of the overlay.
		if(isIE6) {
			$('select').not($box.find('select')).filter(function() {
				return this.style.visibility !== 'hidden';
			}).css({
				'visibility' : 'hidden'
			}).one(event_cleanup, function() {
				this.style.visibility = 'inherit';
			});
		}
		callback = function() {
			var preload, i, total = $related.length, iframe, frameBorder = 'frameBorder', allowTransparency = 'allowTransparency', complete, src, img;

			if(!open) {
				return;
			}

			function removeFilter() {
				if(isIE) {
					$box[0].style.removeAttribute('filter');
				}
			}

			complete = function() {
				clearTimeout(loadingTimer);
				$loadingOverlay.hide();
				trigger(event_complete, settings.onComplete);
			};
			if(isIE) {
				//This fadeIn helps the bicubic resampling to kick-in.
				if(photo) {
					$loaded.fadeIn(100);
				}
			}

			$title.html(settings.title).add($loaded).show();

			if(total > 1) {// handle grouping
				if( typeof settings.current === "string") {
					$current.html(settings.current.replace('{current}', index + 1).replace('{total}', total)).show();
				}

				$next[(settings.loop || index < total - 1) ? "show" : "hide"]().html(settings.next);
				$prev[(settings.loop || index) ? "show" : "hide"]().html(settings.previous);

				if(settings.slideshow) {
					$slideshow.show();
				}

				// Preloads images within a rel group
				if(settings.preloading) {
					preload = [getIndex(-1), getIndex(1)];
					while( i = $related[preload.pop()]) {
						src = $.data(i, colorbox).href || i.href;
						if($.isFunction(src)) {
							src = src.call(i);
						}
						if(isImage(src)) {
							img = new Image();
							img.src = src;
						}
					}
				}
			} else {
				$groupControls.hide();
			}

			if(settings.iframe) {
				iframe = $tag('iframe')[0];

				if( frameBorder in iframe) {
					iframe[frameBorder] = 0;
				}
				if( allowTransparency in iframe) {
					iframe[allowTransparency] = "true";
				}
				// give the iframe a unique name to prevent caching
				iframe.name = prefix + (+new Date());
				if(settings.fastIframe) {
					complete();
				} else {
					$(iframe).one('load', complete);
				}
				iframe.src = settings.href;
				if(!settings.scrolling) {
					iframe.scrolling = "no";
				}
				$(iframe).addClass(prefix + 'Iframe').appendTo($loaded).one(event_purge, function() {
					iframe.src = "//about:blank";
				});
			} else {
				complete();
			}

			if(settings.transition === 'fade') {
				$box.fadeTo(speed, 1, removeFilter);
			} else {
				removeFilter();
			}
		};
		if(settings.transition === 'fade') {
			$box.fadeTo(speed, 0, function() {
				publicMethod.position(0, callback);
			});
		} else {
			publicMethod.position(speed, callback);
		}
	};

	publicMethod.load = function(launched) {
		var href, setResize, prep = publicMethod.prep;
		active = true;
		photo = false;
		element = $related[index];

		if(!launched) {
			makeSettings();
		}

		trigger(event_purge);

		trigger(event_load, settings.onLoad);

		settings.h = settings.height ? setSize(settings.height, 'y') - loadedHeight - interfaceHeight : settings.innerHeight && setSize(settings.innerHeight, 'y');

		settings.w = settings.width ? setSize(settings.width, 'x') - loadedWidth - interfaceWidth : settings.innerWidth && setSize(settings.innerWidth, 'x');

		// Sets the minimum dimensions for use in image scaling
		settings.mw = settings.w;
		settings.mh = settings.h;

		// Redo the minimum width and height calculations based on maxWidth and maxHeight values.
		// If the width or height exceed the maxWidth or maxHeight, use the maximum values instead.
		if(settings.maxWidth) {
			settings.mw = setSize(settings.maxWidth, 'x') - loadedWidth - interfaceWidth;
			settings.mw = settings.w && settings.w < settings.mw ? settings.w : settings.mw;
		}
		if(settings.maxHeight) {
			settings.mh = setSize(settings.maxHeight, 'y') - loadedHeight - interfaceHeight;
			settings.mh = settings.h && settings.h < settings.mh ? settings.h : settings.mh;
		}
		href = settings.href;
		loadingTimer = setTimeout(function() {
			$loadingOverlay.show();
		}, 100);
		if(settings.inline) {
			// Inserts an empty placeholder where inline content is being pulled from.
			// An event is bound to put inline content back when ColorBox closes or loads new content.
			$tag(div).hide().insertBefore($(href)[0]).one(event_purge, function() {
				$(this).replaceWith($loaded.children());
			});
			prep($(href));
		} else if(settings.iframe) {
			// IFrame element won't be added to the DOM until it is ready to be displayed,
			// to avoid problems with DOM-ready JS that might be trying to run in that iframe.
			prep(" ");
		} else if(settings.html) {
			prep(settings.html);
		} else if(isImage(href)) {
			$( photo = new Image()).addClass(prefix + 'Photo').error(function() {
				settings.title = false;
				prep($tag(div, 'Error').text('This image could not be loaded'));
			}).load(function() {
				var percent;
				photo.onload = null;
				//stops animated gifs from firing the onload repeatedly.

				if(settings.scalePhotos) {
					setResize = function() {
						photo.height -= photo.height * percent;
						photo.width -= photo.width * percent;
					};
					if(settings.mw && photo.width > settings.mw) {
						percent = (photo.width - settings.mw) / photo.width;
						setResize();
					}
					if(settings.mh && photo.height > settings.mh) {
						percent = (photo.height - settings.mh) / photo.height;
						setResize();
					}
				}

				if(settings.h) {
					photo.style.marginTop = Math.max(settings.h - photo.height, 0) / 2 + 'px';
				}

				if($related[1] && (settings.loop || $related[index + 1])) {
					photo.style.cursor = 'pointer';
					photo.onclick = function() {
						publicMethod.next();
					};
				}

				if(isIE) {
					photo.style.msInterpolationMode = 'bicubic';
				}

				setTimeout(function() {// A pause because Chrome will sometimes report a 0 by 0 size otherwise.
					prep(photo);
				}, 1);
			});
			setTimeout(function() {// A pause because Opera 10.6+ will sometimes not run the onload function otherwise.
				photo.src = href;
			}, 1);
		} else if(href) {
			$loadingBay.load(href, settings.data, function(data, status, xhr) {
				prep(status === 'error' ? $tag(div, 'Error').text('Request unsuccessful: ' + xhr.statusText) : $(this).contents());
			});
		}
	};
	// Navigates to the next page/image in a set.
	publicMethod.next = function() {
		if(!active && $related[1] && (settings.loop || $related[index + 1])) {
			index = getIndex(1);
			publicMethod.load();
		}
	};

	publicMethod.prev = function() {
		if(!active && $related[1] && (settings.loop || index)) {
			index = getIndex(-1);
			publicMethod.load();
		}
	};
	// Note: to use this within an iframe use the following format: parent.$.fn.colorbox.close();
	publicMethod.close = function() {
		if(open && !closing) {
			closing = true;
			open = false;

			trigger(event_cleanup, settings.onCleanup);

			$window.unbind('.' + prefix + ' .' + event_ie6);

			$overlay.fadeTo(200, 0);

			$box.stop().fadeTo(300, 0, function() {

				$box.add($overlay).css({
					'opacity' : 1,
					cursor : 'auto'
				}).hide();

				trigger(event_purge);

				$loaded.remove();

				setTimeout(function() {
					closing = false;
					trigger(event_closed, settings.onClosed);
				}, 1);
			});
		}
	};
	// Removes changes ColorBox made to the document, but does not remove the plugin
	// from jQuery.
	publicMethod.remove = function() {
		$([]).add($box).add($overlay).remove();
		$box = null;
		$('.' + boxElement).removeData(colorbox).removeClass(boxElement).die();
	};
	// A method for fetching the current element ColorBox is referencing.
	// returns a jQuery object.
	publicMethod.element = function() {
		return $(element);
	};

	publicMethod.settings = defaults;

}(jQuery, document, this));

/*
 * zuperSlider v1.6.1 - http://hotwp.net/
 *
 * Copyright - 2012 Mihai Buricea (http://hotwp.net/)
 * All rights reserved.
 *
 * You may not modify and/or redistribute this file
 * save cases where Extended License has been purchased
 *
*/

(function ($) {
        
    /**
     * zuperSlider constructor
     * 
     * obj - the current slider instance
     * settings - slider seetings
     */          
    var zuperSlider = function (obj, settings) {
        
        var t = this, parent;
        
        // script versione
        t.ver = 'v1.6.1';
        
        // browser type (for ie support)
        if ($.browser.msie) {
            if (parseInt($.browser.version) <= 8) {
                t.ie78 = true;
            } else if (parseInt($.browser.version) == 9) {
                t.ie9 = true;
				t.ie9ResponsiveProblem = true;
            }
        }
        
        // the slider
        t.obj = obj;
        
        // settings
        t.settings = settings;
        
        // effect status
        t.active =  false; 
        
        // variable used by auto & destroy method
        t.delayStop = false;
        
        // get the ul element from slider
        t.ul = t.obj.find('>ul');
        
        // get the ul length
        t.ul_nr = t.ul.children().length;        
                
        // if  slider has only one <li> stops the slide
        if (t.ul_nr < 2) {
			// set the slider width and height
			t.ul.css({visibility: 'visible'});
			return;
        }
        
        // internal needs (do not modify)
        t.settings.animate.perPage = 1;       
        
        // callback function for public methods
        t.callbackFunction = null;
        
        // callback function for start or end of slides
        t.callbackFunctionItemsStart = [];
        t.callbackFunctionItemsEnd = [];
		
        // callback function for captions
        t.callbackCaption = null;
		
        // add loader
        t.obj.addClass('zuperSliderLoader');               
        
        // wrap container to ul element
        t.obj.wrapInner('<div class="container" />');
        
        // get the container width and height
        t.widthContainer = t.ul.width();
        t.heightContainer = t.ul.height(); 

        // get the slider width and height           
        t.sliderWidth   = t.obj.width();
        t.sliderHeight  = t.obj.height();
        
        if (t.settings.animate.type != 'carousel') {
                // get te zuper parent
                parent = t.obj.parent();

                // if attr style is on, remove it and get original max-width and height
                var parentStyle = parent.attr("style");
                parent.removeAttr('style');

                // get the original width and height if mode is 'none' or 'fullscreen' or 'fullwidth'
                if (t.settings.mode == 'none') {
                        t.originalWidth = parseInt(parent.css("max-width"));	
                        if (!t.originalWidth) {
                                t.originalWidth = parseInt(parent.css("width"));					
                        }	

                        t.originalHeight = parseInt(parent.css("height"));

                } else if (t.settings.mode == 'fullscreen') {
                        t.originalWidth = 1920;
                        t.originalHeight = 1200;
                } else if (t.settings.mode == 'fullwidth') {
                        t.originalWidth = 1920;
                        t.originalHeight = parseInt(parent.css("height"));
                }

                parent.attr("style", parentStyle);

                // set the proportion for width and for height
                t.propH = t.sliderWidth / t.originalWidth;
                t.propV = t.sliderHeight / t.originalHeight;		
        } else  {
            // set the proportion for width and for height
            t.propH = 1;
            t.propV = 1;
        }        

        // detect a 'touch screen'
        t.touchDevice = !!('ontouchstart' in window) ? 1 : 0;        

        // create the html, css and events for slider (sets up the slider structure)
        t.htmlCssEvents();
        
        // load the images and background-images of the slider
        t.loading();        
    }    
    
    // PRIVATE METHODS
    zuperSlider.prototype = {
        
        /**
         * Create html and css for slider
         */
        htmlCssEvents: function () {
            var t = this, i, j, temp, indexOrder;

            // index order of the slides
            if (t.settings.order.firstSlide == 'middle') {
                indexOrder = Math.floor(t.ul_nr / 2);
            } else {
                indexOrder  = (t.settings.order.firstSlide < 1)? 0 : parseInt(t.settings.order.firstSlide) - 1;
            }

            // create an array with <li> elements
            t.children  = [];
            t.ul.children().each(function () {
                t.children.push($(this));
            });            

            // create css for carousel slider
            if (t.settings.animate.type == 'carousel') {

                var k, li_nr, curr, el, posL = 0, marginTop, kk, marginLeftBool, opacity, contor,
                    car_nr2 = Math.floor(t.settings.animate.car_nr / 2);

                // calculate the slider width
                for (i = 10, k = 0; i >= 9 - car_nr2; i--) {
                    k += i;
                }

                // set the width for slider elements
                t.obj.css({
                    width: t.sliderWidth * k / 10
                }); 
                t.ul.parent().css({
                    width: t.sliderWidth * k / 10
                });
                t.ul.css({
                    width: t.sliderWidth * k / 10
                });

                // clone <li> to have minim "t.settings.animate.car_nr" li on the page
                li_nr = t.settings.animate.car_nr - t.ul_nr;                    
                for (i = 0; i < li_nr; i++) {                        
                    if (i % 2 == 0) {                            
                        el = t.children[t.ul_nr - 1].clone();
                        t.ul.append(el);
                        t.children.push(el);                            
                    } else {                            
                        el = t.children[0].clone();
                        t.ul.prepend(el);
                        t.children.unshift(el);                            
                    }
                    t.ul_nr++;                        
                }

                // order the elements with index order
                temp = t.children.slice();
                for (i = 0, k = car_nr2; i < t.ul_nr; i++, indexOrder++, k++) {                        
                    if (indexOrder >= t.ul_nr) {
                        indexOrder = 0;
                    } 
                    if (k >= t.ul_nr) {
                        k = 0;
                    }

                    t.children[k] = temp[indexOrder];
                }

                // clones the <li> if I have too few slides
                if (t.ul_nr - t.settings.animate.car_nr < car_nr2) {
                    for (i = 0; i < t.ul_nr; i++) {
                        j = t.children[i].clone();
                        t.ul.append(j);
                        t.children.push(j);
                    }
                    t.ul_nr *= 2;
                }
                
                // add class active3 on the middle slide
                t.children[car_nr2].addClass('active3');
                t.index = car_nr2;

                // contor that hold the variable to manipulate the li
                contor      = 9 - car_nr2; 
                 // align the slide verticaly
                marginTop   = 0, //[5, 6, 7, 7.5, 7.7, 7.8, 7.9, 7.92, 7.94, 7.96, 7.98],
                // kk is index for marginTop
                kk          = car_nr2,  
                // image opacity
                opacity     = 0; 

                // build the <li> position
                for (i = 0; i < t.ul_nr; i++) {
                    curr = t.children[i];
                    curr.hide();
                    if (i < t.settings.animate.car_nr) {
                        if (i <= car_nr2) {
                            posL += t.sliderWidth * contor / 20;
                            contor++;
                            kk--;
                            opacity = contor / 10;
                        } else if (i >  car_nr2) {
                            posL += t.sliderWidth * (contor + 1) / 20;
                            contor--;
                            kk++;
                            opacity = contor / 10;
                        }

                        if (typeof marginTop[kk] === "undefined") marginTop[kk] = 0;

                        // change the <li>
                        curr.css({ 
                            width:      t.sliderWidth * contor / 10,
                            height:     t.sliderHeight * contor / 10,
                            zIndex:     contor,
                            left:       posL,
                            marginTop:  0 //(t.sliderHeight - t.sliderHeight * contor / 10) * (marginTop[kk] / 10)
                        });

                        // positioning images of slider
                        curr.find('img').css({ 
                            width:      t.sliderWidth * contor / 10,
                            height:     t.sliderHeight * contor / 10,
                            opacity:    opacity
                        });

                    } else {
                        contor = 9 - car_nr2;

                        curr.css({
                            width:      t.sliderWidth * contor / 10,
                            height:     t.sliderHeight * contor / 10,
                            zIndex:     contor,
                            left:       0,
                            marginTop:  0, //(t.sliderHeight - t.sliderHeight * contor / 10) * (marginTop[kk] / 10)
                            opacity:    0
                        });

                        curr.find('img').css({ 
                            width:      t.sliderWidth * contor / 10,
                            height:     t.sliderHeight * contor / 10,
                            opacity:    contor / 10
                        });
                    }
                }

                // on click animate the carousel
                t.ul.children().bind('click', function (e) {

                    var elem = $(this);

                    for (i = 0; i < t.children.length; i++) {
                        if (elem[0] == t.children[i][0]) {
                            break;
                        }
                    }

                    if (!t.children[i].hasClass('active3')) {
                        hotwp.jumpToItem(i, t);
                        return false;
                    }
                });
            } else {                
                // ordonate de slides
                temp = t.children.slice();
                for (i = 0; i < t.ul_nr; i++, indexOrder++) {
                    if (indexOrder >= t.ul_nr) indexOrder = 0;
                    t.children[i] = temp[indexOrder];
                }

                // start slide
                if (t.settings.order.startSlide == 'middle') {
                    t.index = Math.floor(t.ul_nr / 2);
                } else {
                    t.index  = (t.settings.order.startSlide < 1)? 0 : parseInt(t.settings.order.startSlide) - 1;
                }
                
                // multiple effects is active
                if (t.settings.multipleEff.active) {
                    t.multipleEffects(t.index);
                }                
                
           
            }

            // touch navigation is enabled
            if (t.propertyIsActive('touchNavigation')) {                           
                
                t.ul.addClass('grab');

                if (t.touchDevice) {
                    t.mousedown = "touchstart.hs";
                    t.mousemove = "touchmove.hs";
                    t.mouseup   = "touchend.hs";
                } else {
                    t.mousedown = "mousedown.hs";
                    t.mousemove = "mousemove.hs";
                    t.mouseup   = "mouseup.hs"
                }

                t.ul.bind(t.mousedown, function (e) {            												
					
                    // state for links
                    t.clickState = true;                    				
					
                    // if current element has class nonDrag -> don't do drag or is link                    
                    if ($(e.target).hasClass('nonDrag')) {
                        e.stopImmediatePropagation();
                        e.stopPropagation();
                        return true;
                    }
                    
                    // if 'touch device' is false
                    if (!t.touchDevice) {
                        if (e.preventDefault) { 
                            e.preventDefault();
                        }                        
                    }                                      
                   
                    var ee = e;
                                        
                    if (t.touchDevice) {
                        var b = e.originalEvent.touches;
                        if (b.length > 1) {
                            return false
                        }
                        e = b[0];
                    }           
                    
                    // touch is started
                    t.touchStart = 0;
                    
                    t.touchPos = 0

                    if (t.ie78) {
						// disable multiple effects 
						if (t.active) return false;
						
						t.active = true;           
						
                        var s = {};
                        s.pageX = e.pageX;
                        
                        $(document).bind(t.mousemove, function (e) {
                            if (e.preventDefault) { 
                                e.preventDefault();
                            }
                            
                            s.pageX1 = e.pageX;
                          
                            t.touchMouseMove(s);   
                        });

                        $(document).bind(t.mouseup, t, t.touchMouseUp);
                        
                    } else  {
					
                        $(document).bind(t.mousemove, {pageX: e.pageX, pageY: e.pageY, me: t, ee: ee}, t.preTouchMouseMove);

                        $(document).bind(t.mouseup, t, t.touchMouseUp);                        
                    }

                    return true;

                }).bind('click', function (e) {   
                    return t.clickState;
                });
            }

            // if navigation is enabled
            if (t.propertyIsActive('nav')) {

                var nav_class = "nav", cnt, ulNavChildren;

                // add nav items
                if (t.settings.nav.type == 'numbers') {
                    nav_class = "nav_num";
                } else if (t.settings.nav.type == 'images') {
                    nav_class = "nav_img";
                }

                cnt = '<div class="zuperNav"><ul class="' + nav_class + '">';

                for (i = 0; i < t.ul_nr; i++) {
                    cnt += (i == t.index)? '<li class="active">' : '<li>';
                    // numbers
                    if (t.settings.nav.type == 'numbers') {
                        cnt += i+1;
                    }
                    cnt += '</li>';
                }

                cnt += '</ul></div>';

                t.nav = $(cnt);

                // add navigation to slider
                t.nav.appendTo(t.obj);               
                
                // create an array with navagation <li> elements
                t.navChildren = [];
                ulNavChildren = t.nav.find('ul').children();
                
                ulNavChildren.each(function () {
                    t.navChildren.push($(this));
                });
                
                if (t.settings.navigateOnHover) {
                    ulNavChildren.bind('mouseenter', function (e) {
                        hotwp.jumpToItem($(this).index(), t);
                    });                     
                }
                
                ulNavChildren.bind('click', function (e) {
                    hotwp.jumpToItem($(this).index(), t);
                });                  

                // thumbs for navigation is enabled
                if (t.settings.nav.thumbs) {

                    var thumb;

                    // on hover show the thumbs
                    t.nav.find('li').hover(
                        function () {

                            var what = $(this), position = what.position(), img, temp, src, index = what.index();

                            if (t.children[index].attr('dataThumbSrc')) {
                                src = t.children[index].attr('dataThumbSrc');
                            } else {
                                src = t.children[index].find('img').attr('src');
                            }

                            temp    = t.settings.nav.thumbsDimension.split('x');
                            img     = t.cropResizeImage(src, temp[0], temp[1]);

                            thumb = $('<div class="nav_thumb"><div style="width:' + temp[0] + 'px;height:' + temp[1] + 'px;"><img src="' + img.src + '" width="' + img.width + '" height="' + img.height + '"  /></div></div>');
                            t.nav.append(thumb);

                            thumb.css({
                                top: position.top - thumb.outerHeight(true) - 4,
                                left: position.left - thumb.outerWidth(true) / 2 + what.outerWidth(true) / 2
                            });
                            
                            // if 'touch device' trigger the click event on navigation
                            if (t.touchDevice) {
                                what.trigger('click');
                            }
                        },
                        function () {
                            if (thumb) {
                                thumb.remove();
                            }
                        }
                        );
                }
            }

            // next/prev is enabled
            var next_prev = "";

            // if next button is active
            if (t.settings.arrows.next) {
                next_prev = '<div class="arrow next"></div>';
            }

            // if prev button is active
            if (t.settings.arrows.prev) {
                next_prev += '<div class="arrow prev"></div>';
            }

            if (next_prev) {
                var nextPrev = $(next_prev);

                // add to slider
                nextPrev.appendTo(t.obj);

                // events for arrows
                nextPrev.bind('click', function () {
                    
                    var elem = $(this);

                    if (elem.hasClass('next') ) {
                        hotwp.nextItem(t);
                    } else if (elem.hasClass('prev')) {
                        hotwp.prevItem(t);
                    }
                });
                
                if (t.settings.navigateOnHover) {
                    nextPrev.bind('mouseenter', function () {
                        var elem = $(this);

                        if (elem.hasClass('next') ) {
                            hotwp.nextItem(t);
                        } else if (elem.hasClass('prev')) {
                            hotwp.prevItem(t);
                        }
                    });                  
                }                
            }

            // auto is enabled
            if (t.settings.auto.active) {
                
                // the slider flag that is false by default
                t.flagStop = false;
                
                // stop slider on hover (if that option is enabled)                
                t.hoverStop = false;
                
                // stop the auto when the touch is on
                t.touchStop = false;
                          
                // circular is not supported on ie7 and ie8
                if (t.settings.auto.timer == 'circular' && t.ie78) {
                    t.settings.auto.timer = 'none';
                }
                
                // none
                if (t.settings.auto.timer == 'none') { 
                    t.intervalTimer = '';
                    t.intervalContor = 5;

                // line
                } else if (t.settings.auto.timer == 'line') { 
                    var wrapTimer = $('<div class="wrapTimer"><div class="timer"></div></div>');
                    t.obj.append(wrapTimer);
                    wrapTimer.css({
                        top : t.customPosition(wrapTimer, t.settings.auto.posVertical, 'vertical'),
                        left: t.customPosition(wrapTimer, t.settings.auto.posHorizontal, 'horizontal')
                    });

                    t.intervalTimer = wrapTimer.find('.timer');
                    t.lineWidth = parseInt(wrapTimer.css("width"));
                    t.intervalTimer.css({width: 0});

                    t.intervalContor = parseInt(t.lineWidth / 2);

                // circular
                } else if (t.settings.auto.timer == 'circular') {
                    t.intervalTimer = $('<div class="circular"><div class="circularWrap"><div class="circularLeft"></div><div class="circularRight"></div></div></div>');
                    t.obj.append(t.intervalTimer);

                    t.intervalTimer.css({
                        top : t.customPosition(t.intervalTimer, t.settings.auto.posVertical, 'vertical'),
                        left: t.customPosition(t.intervalTimer, t.settings.auto.posHorizontal, 'horizontal')
                    });

                    t.intervalCircularRight = t.intervalTimer.find('.circularRight');
                    t.intervalCircularLeft = t.intervalTimer.find('.circularLeft');
                    t.intervalCircularWrap = t.intervalTimer.find('.circularWrap');

                    t.intervalContor = 360;

                // numbers
                } else if (t.settings.auto.timer == 'numbers') {
                    t.intervalTimer = $( '<div class="numbers"></div>' );
                    t.obj.append(t.intervalTimer);

                    t.intervalTimer.css({
                        top : t.customPosition(t.intervalTimer, t.settings.auto.posVertical, 'vertical'),
                        left: t.customPosition(t.intervalTimer, t.settings.auto.posHorizontal, 'horizontal')
                    });

                    t.intervalContor = 99;
                }
				
                    t.intervalTimeInter = t.settings.auto.time / t.intervalContor;

                // if play/pause buton is enabled
                if (t.settings.auto.playPause) {
                    var play = $('<div class="playPause play"></div>');
                    t.obj.append(play);

                    play.css({
                        top : t.customPosition(play, t.settings.auto.playPauseVertical, 'vertical'),
                        left: t.customPosition(play, t.settings.auto.playPauseHorizontal, 'horizontal')
                    });

                    // on click pause/resume the slider
                    play.bind('click', function () {
                        if (t.settings.auto.playPause) {
                            t.settings.auto.playPause = false;
                            
                            play.removeClass('play').addClass('pause');

                            // pause the auto
                            t.flagStop = true;
                            clearInterval(t.run);
                        } else {                         
                            t.settings.auto.playPause = true;
                            
                            play.removeClass('pause').addClass('play');

                            // start the auto
                            t.flagStop = false;
                            t.startAuto();
                        }
                    });

                    // play / pause state on hover and 'touch device' is false
                    if (t.settings.auto.playPauseHover && !t.touchDevice) {                       
                        t.obj.hover(
                            function () {
                                play.show();
                            },
                            function () {                                
                                play.hide();
                            }
                            );
                    }
                }
                
                // on slider hover stop the auto and 'touch device' is false
                if (t.settings.auto.hoverStop && !t.touchDevice) {

                    t.obj.hover(
                        function () {
                            t.hoverStop = true;
                            clearInterval(t.run);
                        },
                        function () {
                            t.hoverStop = false;
                            t.startAuto();
                        }
                    );
                }
            }  
            
            // if mouse wheel is enabled 
            if (t.settings.navigateWithMouseWheel) {

                /** Event handler for mouse wheel event.
                */
                function wheel(event){
                        var delta = 0;
                        event = event || window.event;
                        
                        if (event.wheelDelta) {
                            delta = event.wheelDelta/120;
                        } else if (event.detail) {
                            delta = -event.detail/3;
                        }                                                
                        
                        if (delta > 0) {                            
                            hotwp.prevItem(t);
                        } else {
                            hotwp.nextItem(t);                            
                        }
 
                        if (event.preventDefault)
                                event.preventDefault();
                        event.returnValue = false;
                }

                if (window.addEventListener) {
                    t.obj[0].addEventListener('DOMMouseScroll', wheel, false);
                    
					if (t.propertyIsActive('nav')) {
						t.nav[0].addEventListener('DOMMouseScroll', function (event) {
							return true;
							event.stopPropagation();
							
							var delta = 0;
							event = event || window.event;
							
							if (event.wheelDelta) {
								delta = event.wheelDelta/120;
							} else if (event.detail) {
								delta = -event.detail/3;
							}                                                
							
							var scrollBar = t.nav.find('.zuperScrollbar'),
								scrollUl = t.nav.find('ul'),
								topRight, topLeft;                              
							
							if (delta > 0) {                            

								topRight = parseInt(scrollBar.css("top")) - t.tempRight;
								topLeft = parseInt(scrollUl.css("top")) + t.tempLeft; 

								if (topLeft >= 0) {
									topRight = 0;
									topLeft = 0;
								}

							} else {
								
								var ulHeight = t.nav.height();
								
								topRight = parseInt(scrollBar.css("top")) + t.tempRight;
								topLeft = parseInt(scrollUl.css("top")) - t.tempLeft;                                                                                     
								
								if (Math.abs(topLeft) >= Math.abs(scrollUl.height() - ulHeight)) {
																	
									topRight = ulHeight - scrollBar.height() + 1;
									topLeft = -scrollUl.height() + ulHeight;                                
								}
							   
							}
							
							t.nav.find('.zuperScrollbar').css({top: topRight});
							t.nav.find('ul').css({top: topLeft}); 
	 
							if (event.preventDefault)
									event.preventDefault();
							event.returnValue = false;
							
						}, false);
					}
                }
                t.obj[0].onmousewheel = wheel;

            }
            
            // if responsive is enabled
            if (t.settings.responsive && t.settings.animate.type != 'carousel') {
                //var resize = 'onorientationchange' in window ? 'orientationchange.hs' : 'resize.hs';				
                var resize = 'resize.hs';
				
                $(window).bind(resize, function () {							

                    if (t.ie9ResponsiveProblem) {
                        t.ie9ResponsiveProblem = false;
                        return;
                    }				

                    var newWidth = t.obj.width(),
                        newHeight = t.obj.height();		

                    if (newWidth != t.sliderWidth || newHeight != t.sliderHeight) {
                        
                        t.sliderWidth = newWidth;
                        t.sliderHeight = newHeight;

                        // get the container width and height
                        t.widthContainer = t.ul.width();
                        t.heightContainer = t.ul.height();                         

                        t.propH = t.sliderWidth / t.originalWidth;
                        t.propV = t.sliderHeight / t.originalHeight;

                        // update position for slider elements
                        t.updateSliderDimension();	
                    }

					
                });        
            }            
        },

        /**
         * Load all images slide
         */
        loading: function () {

            var imgs = [], i, img, propertyValue, t = this, src;

            $.expr[':'].uncached = function (elem) {
                if (!$(elem).is('img[src!=""]')) {
                    return false;
                }

                img = document.createElement('img');
                img.src = elem.src;

                return !img.complete;
            }

            var matchUrl = /url\((['"]?)(.*?)\1\)/g;

            // get all elements
            t.obj.find('*').each(function () {

                var elem = $(this);

                if (elem.is('img:uncached')) {
                    imgs.push({
                        src: elem.attr('src'),
                        element: elem[0]
                    });
                }

                // background image
                propertyValue = elem.css('backgroundImage');
                if (propertyValue) {
                    var match;
                    while ((match = matchUrl.exec(propertyValue))) {
                        imgs.push({
                            src: match[2],
                            element: elem[0]
                        });
                    }
                }

                // if dataThumbSrc attribute is set get the value
                propertyValue = elem.attr('dataThumbSrc');
                if (propertyValue) {
                    imgs.push({
                        src:propertyValue,
                        element: elem[0]
                    });
                }
            });

            // slider has background-image
            propertyValue = t.obj.css('backgroundImage');
            if ( propertyValue) {
                var match;
                while ((match = matchUrl.exec(propertyValue))) {
                    imgs.push({
                        src: match[2]
                    });
                }
            }

            var imgsLength = imgs.length, imgsLoaded = 0;

            if (imgsLength == 0) {
                t.showSlider(t.obj);
            }

            // load  the image and call showSlider method on done
            for (i = 0; i < imgsLength; i++) {
                img = new Image();
                $(img).bind('load.hs error.hs', function () {
                    imgsLoaded++;

                    if (imgsLoaded == imgsLength) {
                        t.showSlider(t.obj);
                        return false;
                    }
                });
                img.src = imgs[i].src;
            }
        },
        
        /**
         * After the images is loaded show the slider
         */
        showSlider: function () {
            var i, img, txt, temp, src, img, oneTime = true, t = this;

            // if navigation 'type = images' recalculate the navigation dimension
            if (t.propertyIsActive('navImages')) {

                // crop & resize & append images
                for (i = 0; i < t.ul_nr; i++) {
                    if (t.children[i].attr('dataThumbSrc')) {
                        src = t.children[i].attr('dataThumbSrc');
                    } else {
                        src = t.children[i].find('img').attr('src');
                    }

                    temp    = t.settings.nav.imagesDimension.split('x');
                    img     = t.cropResizeImage(src, temp[0], temp[1]);

                    t.navChildren[i].css({
                        width: temp[0],
                        height: temp[1]
                    });

                    t.navChildren[i].append(img);
                    txt = t.children[i].attr('dataThumbContent');

                    if (txt) t.navChildren[i].append(txt);
                }
                
                var scrollWrap = t.nav.height(),
                    scrollUl = t.nav.find('ul').height();
                
                t.scrollHeight = 50;
                
                temp = scrollWrap - scrollUl;
                
                if (temp <= 0) {
                    temp = Math.abs(temp);
                    var temp2 = Math.ceil(temp / t.scrollHeight);
                    
                    t.tempLeft = Math.ceil(temp / temp2);

                    t.tempRight = scrollWrap / (temp2 + 1);
                    
                } else {
                    
                }

                //t.nav.append('<div class="zuperWrapScrollbar"><div class="zuperScrollbar" style="height:' + t.tempRight + 'px"></div></div>');
            }
            
            // positiong the slider elements
            t.updateSliderDimension();
            
            // remove the loader
            t.obj.removeClass('zuperSliderLoader');

            // show the slider
            if (t.settings.animate.type == 'carousel') {
                t.ul.parent().css({visibility: 'visible'});

                var car_nr2 = Math.floor(t.settings.animate.car_nr / 2), showLi;

                // show the slide elements
                i = car_nr2;
                showLi = setInterval(function () {
                    if (i == car_nr2) {
                        t.children[i].fadeIn();
                    } else {
                        t.children[i].fadeIn();
                        t.children[t.settings.animate.car_nr - 1 - i].fadeIn();
                    }

                    if (i <= 0) {
                        clearInterval(showLi);

                        t.obj.children().each(function () {
                            var tt = $(this);
                            if (!tt.hasClass('container')) {
                                tt.css({display: 'none', visibility: 'visible'});
                            }
                            
                        });
                        t.obj.children().show();
                        
                        if(t.propertyIsActive('caption')) {
                            t.caption(t.children[t.index], 'on');
                        }
                            
                        if(t.propertyIsActive('caption')) {
                            t.caption(t.children[t.index], 'on');
                        }                            
                        if (t.settings.auto.playPauseHover) {
                            t.obj.find('.playPause').hide();
                        }                                
                            
                    }

                    i--;
                }, 150);
                
                
            } else {
                t.obj.children().each(function () {                    
                    $(this).css({display: 'none', visibility: 'visible'});
                });
                
                // add class active3 on slide
                t.children[t.index].addClass('active3');
                
                // show de slider with fadeIn method
                t.obj.children().fadeIn('normal',
                    function () {                      
                        if (oneTime) {
                            oneTime = false;
                            if(t.propertyIsActive('caption')) {
                                t.caption(t.children[t.index], 'on');

                            }
                            
                            // if  play/pause button is enabled hide it
                            if (t.settings.auto.playPauseHover) {
                                t.obj.find('.playPause').hide();
                            }
                        }
                    });
            }
            
            // start the auto if auto is enabled
            if (t.settings.auto.active){            
                t.startAuto();
            }
        },
        
        /**
         * Update slider elements position
         */
        updateSliderDimension: function () {
            var temp, t = this;
			
            t.active = true;
            // scale and center images that have class="zuper"
            if (t.settings.bgImageScaleAndCenter) {
                // array with images
                var imagesArray = [], i, j, dim, widthImg, heightImg, propWidth, propHeight, img, originalW, originalH;

                for(i = 0; i < t.children.length; i++) {
                    img = t.children[i].find('img.zuper');
                    
                    if (img.length){
                        imagesArray.push(img[0]);
                    }
                }
                
                if (imagesArray.length > 0) {
                    for (i = 0; i < imagesArray.length; i++) {        
                        
						widthImg = parseInt(imagesArray[i].getAttribute('data-width'));
						heightImg = parseInt(imagesArray[i].getAttribute('data-height'));
						
						if (!widthImg) {
							widthImg    = imagesArray[i].width;
							imagesArray[i].setAttribute('data-width', widthImg)							
						}						
						if (!heightImg) {
							heightImg    = imagesArray[i].height;
							imagesArray[i].setAttribute('data-height', heightImg)							
						}
						
                        propWidth   = widthImg / t.sliderWidth;
                        propHeight  = heightImg / t.sliderHeight;								
								
						// remove img style
						imagesArray[i].setAttribute('style', '');						
						
                        if (propWidth < 1 || propHeight < 1) {
                            if (widthImg > t.sliderWidth) {
                                imagesArray[i].style.marginLeft = 0 + "px"; //= -Math.floor((widthImg - t.sliderWidth) / 2)
                            } else if (widthImg < t.sliderWidth) {
                                imagesArray[i].style.marginLeft = 0 + "px"; //= Math.floor((t.sliderWidth - widthImg) / 2)
                            }

                            if (heightImg > t.sliderHeight) {
                                imagesArray[i].style.marginTop = 0 + "px"; //-Math.floor((heightImg - t.sliderHeight) / 2)
                            } else if (heightImg < t.sliderHeight) {
                                imagesArray[i].style.marginTop = 0 + "px"; //= Math.floor((t.sliderHeight - heightImg) / 2)
                            }
                        } else if (propWidth > propHeight) {
                            imagesArray[i].width = Math.ceil(widthImg / propHeight);
                            imagesArray[i].height = Math.ceil(heightImg / propHeight);

                            imagesArray[i].style.marginLeft = -Math.floor((widthImg / propHeight - t.sliderWidth) / 2) + "px";
                        } else if (propHeight > propWidth) {
                            imagesArray[i].width = Math.ceil(widthImg / propWidth);
                            imagesArray[i].height = Math.ceil(heightImg / propWidth);

                            imagesArray[i].style.marginTop = -Math.floor((heightImg / propWidth - t.sliderHeight) / 2) + "px";
                        } else {
                            imagesArray[i].width = Math.ceil(widthImg / propWidth);
                            imagesArray[i].height = Math.ceil(heightImg / propHeight);
                        }
                    } 
                }
            }             
            
            // update arrows position
            if (t.settings.arrows.next) {
                temp = t.obj.find('.next');

                //set the css for next button
                temp.css({
                    top : t.customPosition(temp, t.settings.arrows.nextVertical, 'vertical'),
                    left: t.customPosition(temp, t.settings.arrows.nextHorizontal, 'horizontal')
                });
            }

            if (t.settings.arrows.prev) {
                temp = t.obj.find('.prev');

                //set the css for prev button
                temp.css({
                    top : t.customPosition(temp, t.settings.arrows.prevVertical, 'vertical'),
                    left: t.customPosition(temp, t.settings.arrows.prevHorizontal, 'horizontal')
                });
            }   

            // update auto position
            if (t.settings.auto.active) {  
                if (t.settings.auto.timer == 'line') {
                    temp = t.obj.find('.wrapTimer');
                    
                    temp.css({
                        top : t.customPosition(temp, t.settings.auto.posVertical, 'vertical'),
                        left: t.customPosition(temp, t.settings.auto.posHorizontal, 'horizontal')                    
                    });
                    
                    t.lineWidth  = parseInt(temp.css('width')) * t.propH;

                } else if (t.settings.auto.timer == 'circular') {
                    temp = t.obj.find('.circular');                                        
                    
                    temp.css({
                        top : t.customPosition(temp, t.settings.auto.posVertical, 'vertical'),
                        left: t.customPosition(temp, t.settings.auto.posHorizontal, 'horizontal')
                    });

                } else if (t.settings.auto.timer == 'numbers') {
                    temp = t.obj.find('.numbers');

                   temp.css({
                        top : t.customPosition(temp, t.settings.auto.posVertical, 'vertical'),
                        left: t.customPosition(temp, t.settings.auto.posHorizontal, 'horizontal')
                    });
                }

                if (t.settings.auto.playPause) {
                    temp = t.obj.find('.playPause');

                    temp.css({
                        top : t.customPosition(temp, t.settings.auto.playPauseVertical, 'vertical'),
                        left: t.customPosition(temp, t.settings.auto.playPauseHorizontal, 'horizontal')
                    });
                }
            }              
            
            // update nav position
            if (t.propertyIsActive('nav')) {
                t.nav.css({
                    top : 0, //t.customPosition(t.nav, t.settings.nav.navVertical, 'vertical'),
                    left: 0 //t.customPosition(t.nav, t.settings.nav.navHorizontal, 'horizontal')
                })
            }            
            
			// if caption is enabled run the calback function for captions
			if(t.propertyIsActive('caption')) {
				t.settings.captionCallback.call(t.obj, t.sliderWidth, t.sliderHeight);
			}							
			
            t.active = false;
        },
        
        /**
         * Update caption position and dimension
         */
        updateCaptionPosition: function () {   
                var cap = [], t = this, i, valTop, valLeft;
                
                // get all the captions
                t.obj.find('.caption').each(function () {
                    cap.push($(this));
                });                  
                
                // update position and dimension
                for (i = 0; i < cap.length; i++) {
                    valTop = 0;
                    valLeft = 0;
                    
                    cap[i].removeAttr('style');
                    var paddingLeft, paddingTop, paddingRight, paddingBottom, css = {};
                    
                    if (parseInt(cap[i].css("top")) > t.originalHeight / 2) {
                        if (t.propV < 0.9) {
                            valTop = 40;
                        }

                        if (t.propV < 0.8) {
                            valTop = 60;
                        }

                        if (t.propV < 0.7) {
                            valTop = 80;
                        }                        
                    }
                    
					// @bug cu t.originalWidth
                    if (parseInt(cap[i].css("left")) > t.originalWidth / 2) {
                        if (t.propH < 0.9) {
                            valLeft = 40;
                        }

                        if (t.propH < 0.8) {
                            valLeft = 60;
                        }

                        if (t.propH < 0.7) {
                            valLeft = 80;
                        }                      
                    }

                            
                    css.opacity = 1;
                    css.top = parseInt(cap[i].css("top")) * t.propV - valTop;
                    css.left = parseInt(cap[i].css("left")) * t.propH - valLeft;
                    
                    cap[i].css(css);
                    
                    if (t.propH < 0.6) {
                        cap[i].hide();
                    }                    
                }            
        },
        
        /**
         * When the touch is finished
         */
        touchMouseUp: function (e) {
            var t = e.data;

            $(document).unbind(t.mousemove + ' ' + t.mouseup);            
           
            t.ul.removeClass('grabbing');

            var index2 = t.index, index1 = t.index, pos;

            t.touchStop = false;

            if (t.touchPos == 0) {
                t.active = false;
            } else if (Math.abs(t.touchPos) < 31) {
                
                // disable multiple effects
                t.off(index1, index2);
                
                // animate the slide position
                t.ul.animate({left: 0}, t.settings.animate.speed, 'easeOutBounce',
                    function () {
                        t.ul.children().removeClass('active2').removeAttr('style');
                        t.on(index2);
                    }
                );
            } else {
                if (t.touchPos > 0) {
                    index2 = Math.ceil(t.touchPos / t.widthContainer) + t.index;
                    pos = -Math.abs(t.index - index2) * t.widthContainer;
                    if (index2 > t.ul_nr - 1) {
                        index2 = index2 - t.ul_nr;
                    }
                } else if (t.touchPos < 0) {
                    index2 = t.index - Math.ceil(-t.touchPos / t.widthContainer);
                    pos = Math.abs(t.index - index2) * t.widthContainer;
                    if (index2 < 0) {
                        index2 = t.ul_nr + index2;
                    }

                }

                // disable multiple effects
                t.off(index1, index2);

                // move the ul element
                t.ul.animate({
                    left: pos
                }, t.settings.animate.speed,
                function () {
                    t.ul.children().removeClass().removeAttr('style');
                    t.children[index2].addClass('active3');

                    t.ul.css({
                        left: 0
                    });

                    // enable efects
                    t.on(index2);
                });
            }

            return true;
        },
        
        /**
         * Prepare the touch feature
         */
        preTouchMouseMove: function (e) {
            var t = e.data.me, pageX = e.data.pageX, pageY = e.data.pageY, ee = e.data.ee, eee = e, s = {};             
			
            // desktop or mobile
            if (t.touchDevice) {
                var b = e.originalEvent.touches;
                if (b.length > 1) {
                    return false
                }
                e = b[0];
            }           
            
            
            // if touchNafigation is on => go to touchMouseMove function
            if (t.touchStart === 1) {   
                s.pageX = pageX;
                s.pageX1 = e.pageX;
                t.touchMouseMove(s);
            } else if (t.touchStart === 0) {
                
                if (Math.abs(pageX - e.pageX) > 5) {
                    // prevent default effects
                    if (ee.preventDefault) { 
                        ee.preventDefault();
                    }
                    
                    // prevent default effects
                    if (eee.preventDefault) { 
                        eee.preventDefault();
                    }                      

                    // disable multiple effects
                    if (t.active) return false;

                    // clear interval auto
                    if (t.settings.auto.active) { 
                        t.touchStop = true;
                        clearInterval(t.run);
                    }

                    t.active = true;

                    t.touchPos = 0;
                    t.ul.addClass('grabbing');
                                        
                    t.touchStart = 1;
                    
                    t.touchMouseMove(pageX, e.pageX, t);
                 
                } else if (Math.abs(pageY - e.pageY) > 5) {
                    t.touchStart = 2;
                    $(document).unbind(t.mousemove + ' ' + t.mouseup);
                }
            }
            
        },
        
        /**
         * If touch is on, update slider position
         */
        touchMouseMove: function (s) {
            
            var index2, pageX = s.pageX, pageX1 = s.pageX1, t = this;                        
            
            t.touchPos = pageX - pageX1;
            
            // on touch move return false for links
            t.clickState = false;
            
            // next Item
            if (t.touchPos > 0) {
                
                // calculate the slide index who is animate
                index2 = Math.ceil(t.touchPos / t.widthContainer) + t.index;

                // I reached the end of the slider
                if (index2 > t.ul_nr - 1) {
                    index2 = index2 - t.ul_nr;
                }

                // I made ??a complete loop => stop the touch
                if (t.touchPos >= t.widthContainer * (t.ul_nr - 1)) {
                    t.touchPos = t.widthContainer * (t.ul_nr - 1);
                } else {
                    t.children[index2].addClass('active2').css({
                        left:  Math.ceil(t.touchPos / t.widthContainer) * t.widthContainer
                    });
                }
            // prev Item
            } else if (t.touchPos < 0) {
                
                // calculate the slide index who is animate
                index2 = t.index - Math.ceil(-t.touchPos / t.widthContainer);

                // I reached the end of the slider
                if (index2 < 0) {
                    index2 = t.ul_nr + index2;
                }

                // I made a complete loop => stop the touch
                if (Math.abs(t.touchPos) >= t.widthContainer * (t.ul_nr - 1)) {
                    t.touchPos = -t.widthContainer * (t.ul_nr - 1);
                } else {
                    t.children[index2].addClass('active2').css({
                        left:  -Math.ceil(-t.touchPos / t.widthContainer) * t.widthContainer
                    });
                }
            }
            
            t.ul.css({
                left: -t.touchPos
            });

            return false;
        },
        
        /**
         * Start the auto function
         */
        startAuto: function () {
            var t = this;
			
            // if auto is disabled by other elements stop here
            if (!t.active && !t.flagStop && !t.touchStop && !t.hoverStop) {

                // create the auto
                t.run = setInterval(function () {

                    if (t.intervalContor < 0) {             
                        // stop the auto
                        clearInterval(t.run);

                        // trigger next item
                        hotwp.nextItem(t);     

                        return;
                    }   
                    
                    if (t.settings.auto.timer == 'line') {
                        t.intervalTimer.css( 'width', function (index, value) {return parseInt(value) + 2;});
                        
                    } else if (t.settings.auto.timer == 'circular') {        
                        var grade = 181 - t.intervalContor;

                        if (grade < 0) {
                            t.intervalCircularRight.css({
                                "-ms-transform": "rotate(" + grade + "deg)",
                                "-webkit-transform": "rotate(" + grade + "deg)",
                                "-o-transform": "rotate(" + grade + "deg)",
                                "-moz-transform": "rotate(" + grade + "deg)"
                            });
                        } else if (grade == 0) {
                            t.intervalCircularRight.css({
                                "-ms-transform": "rotate(" + grade + "deg)",
                                "-webkit-transform": "rotate(" + grade + "deg)",
                                "-o-transform": "rotate(" + grade + "deg)",
                                "-moz-transform": "rotate(" + grade + "deg)"
                            });

                            var clip = t.intervalCircularWrap.css("clip").replace(/,|rect\(|\)/g, '').split(' ');
                                                        
                            clip = 'rect(0 ' + clip[1] + ' ' + clip[2] + ' 0)';
                            
                            t.intervalCircularWrap.css('clip', clip);
                            t.intervalCircularLeft.show();

                        } else {
                            grade = - t.intervalContor;
                            t.intervalCircularLeft.css({
                                "-ms-transform": "rotate(" + grade + "deg)",
                                "-webkit-transform": "rotate(" + grade + "deg)",
                                "-o-transform": "rotate(" + grade + "deg)",
                                "-moz-transform": "rotate(" + grade + "deg)"
                            });
                        }
                    } else if (t.settings.auto.timer == 'numbers') {
                        var time = 100 - t.intervalContor;

                        if (time < 10) {
                            time = "00" + time;
                        } else if (time < 100) {
                            time = "0" + time;
                        }
                        t.intervalTimer.text(time);
                    }
                    t.intervalContor--;                      
                    
                }, t.intervalTimeInter);
            }
        },
        
        /**
         * Reset the auto and all the elements composing
         **/
        resetAuto: function () {
           
            var t = this;
            
            clearInterval(t.run);

            if (t.settings.auto.timer == 'none') {
                t.intervalContor = 5;                
            } else if (t.settings.auto.timer == 'line') {
                t.intervalContor = parseInt(t.lineWidth / 2);
                t.intervalTimer.css({width: 0});				
				
            } else if (t.settings.auto.timer == 'circular') {
                t.intervalCircularRight.css({
                    "-moz-transform": "rotate(180deg)",
                    "-webkit-transform": "rotate(180deg)",
                    "-o-transform": "rotate(180deg)",
                    "-ms-transform": "rotate(180deg)"
                });

                t.intervalCircularLeft.css({
                    "-moz-transform": "rotate(180deg)",
                    "-webkit-transform": "rotate(180deg)",
                    "-o-transform": "rotate(180deg)",
                    "-ms-transform": "rotate(180deg)"
                });

                t.intervalCircularLeft.hide();

                var clip = t.intervalCircularWrap.css("clip").replace(/,|rect\(|\)|px/g, '').split(' ');

                clip = 'rect(0 ' + clip[1] + 'px ' + clip[2] + 'px ' + clip[2]  / 2 + 'px)';
                t.intervalCircularWrap.css('clip', clip);
                t.intervalContor = 360;
                
            } else if (t.settings.auto.timer == 'numbers') {
                t.intervalTimer.text("");
                t.intervalContor = 99;
            }
        },
        
        /**
         * If random is active mix slides
         * 
         * param index1 - index of current slide
         */
        randomSlide: function (index1) {
            var rand = index1;
            while (rand == index1) {
                rand = Math.floor(Math.random() * this.ul_nr);
            }

            return rand;
        },
        
        /**
         * Caption method
         * 
         * elem - the current slide
         * method - init | destory the captions
         */
        caption: function (elem, method) {

            // dataOffset - number
            // dataDelay - number
            // dataSpeed - number, 'slow', 'normal' or 'fast'
            // dataEasing - 'easing'
            // dataEffects - top, left, right, bottom, fade

            var caption = [], dataOffset, dataEffects, dataEasing, dataDelay, dataSpeed, anim = {}, t = this, i, j, leftPos, topPos, newPos = [], pos;
            
			
			t.obj.find('.caption').css({opacity: 0});
			
            // init the caption
            if (method == 'on') {
                
                // get all captions of current slide
                elem.find('.caption').each(function () {                    
                    caption.push($(this));
                });
				
                // parse the current caption and get 'data' selectors
                for (i = 0; i < caption.length; i++) {
                    
                    pos = caption[i].position();
                    
                    leftPos = pos.left;
                    topPos = pos.top;
					
                    dataOffset = parseInt(caption[i].attr('dataOffset'));
                    if (isNaN(dataOffset)) dataOffset = 10;
                    
                    dataDelay = parseInt(caption[i].attr('dataDelay'));
                    if (isNaN(dataDelay)) dataDelay = 0;
                    
                    dataSpeed = caption[i].attr('dataSpeed');
                    if (typeof dataSpeed === 'undefined') dataSpeed = 'normal';
                    if (!(dataSpeed == 'slow' || dataSpeed == 'normal' || dataSpeed == 'fast')) {
                        dataSpeed = parseInt(dataSpeed);
                    }                    

                    dataEasing = caption[i].attr('dataEasing');
                    if (typeof dataEasing === 'undefined') dataEasing = 'linear';

                    dataEffects = caption[i].attr('dataEffects');
                    if (typeof dataEffects === 'undefined') {
                        dataEffects = ['fade', 'left'];
                    } else {
                        dataEffects = dataEffects.split(" ");
                    }
                    
                    // get the current effects                    
                    if ($.inArray('fade', dataEffects) != -1) {
                        anim.opacity = 1;
                    } else {
                        caption[i].css({opacity: 1});
                    }
                    
                    if ($.inArray('left', dataEffects) != -1) {
                        caption[i].css({left: ((leftPos - dataOffset) * 100 / t.sliderWidth) + '%'});
                        anim.left = (leftPos * 100 / t.sliderWidth) + '%';
                    }                     
                    
                    if ($.inArray('top', dataEffects) != -1) {
                        caption[i].css({top: ((topPos - dataOffset) * 100 / t.sliderHeight) + '%'});
                        anim.top = (topPos * 100 / t.sliderHeight) + '%';
                    }                     
                    
                    if ($.inArray('right', dataEffects) != -1) {
                        caption[i].css({left: ((leftPos + dataOffset) * 100 / t.sliderWidth) + '%'});
                        anim.left = (leftPos * 100 / t.sliderWidth) + '%';
                    }                     
                    
                    if ($.inArray('bottom', dataEffects) != -1) {
                        caption[i].css({top: ((topPos + dataOffset) * 100 / t.sliderHeight) + '%'});
                        anim.top = (topPos * 100 / t.sliderHeight) + '%'; 
                    }     

                    // make the caption effect
                    caption[i].delay(dataDelay).animate(anim, dataSpeed, dataEasing);
                    
                    anim = {};
                                        
                }
            } else if (method == 'off') {}
        },
        
        /**
         * Multiple effects on slider (each slider will have different effect)
         * 
         * param index = index of current element
         */
        multipleEffects: function (index2) {

            var nr, rand, arr, t = this;
            
            // randomize the effects
            if (t.settings.multipleEff.random) {
                rand = Math.floor(Math.random() * t.settings.multipleEff.eff.length);
                nr = (rand >= t.ul_nr)? rand % (t.ul_nr - 1) : rand;
            } else {
                nr = (index2 > (t.settings.multipleEff.eff.length - 1))? (t.settings.multipleEff.eff.length - 1) : index2;
            }

            arr = t.settings.multipleEff.eff[nr].split("|");
            arr[2] = arr[2].split(',');
            arr[3] = arr[3].split(',');
 
            if (arr[0]) {
                t.settings.animate.type = arr[0];
            }
            
            if (arr[1]) {
                t.settings.animate.speed = parseInt(arr[1]);
            }
            
            if (arr[2]) {
                t.settings.animate.position = arr[2];
            }
            
            if (arr[3]) {
                t.settings.animate.effect = arr[3];
            }
            
            if (arr[4]) {
                t.settings.animate.cols = parseInt(arr[4]);
            }
            
            if (arr[5]) {
                t.settings.animate.rows = parseInt(arr[5]);
            }
            
            if (arr[6]) {
                t.settings.animate.delay = parseInt(arr[6]);
            }
            
            if (arr[7]) {
                t.settings.animate.easing = arr[7];
            }
            
            
            if (arr[8]) {
                t.settings.auto.time = parseInt(arr[8]);
            }            
                     
        }, 
        
        /**
         * Disable multiple effects
         * 
         * param index1 = index of current slide
         * param index2 = index of the next slide
         */
        off: function (index1, index2) {
            
            var t = this;
            
            t.active = true;
            
            // reset auto
            if (t.settings.auto.active) {
                t.resetAuto();
            }

            // end callback for slides
            if ($.isFunction(t.callbackFunctionItemsEnd[index1])) {
                t.callbackFunctionItemsEnd[index1].apply(t);
            }

            // start callback for slides
            if ($.isFunction(t.callbackFunctionItemsStart[index2])) {
                t.callbackFunctionItemsStart[index2].apply(t);
            }

            if (t.propertyIsActive('nav')) {
                t.navChildren[index1].removeClass('active');
                t.navChildren[index2].addClass('active');
            }

            if(t.propertyIsActive('caption')) t.caption(t.children[index1], 'off');
        },            
        
        /**
         * Enable effects, change the navigation
         * 
         * param index2 = index of the next slide
         */
        on: function (index2) {
            
            var t = this;
            
            if (t.delayStop) {
                delete this;
                return;
            }
            
            t.active  = false;
            
            // start auto
            if (t.settings.auto.active) {
                // if multiple effects enabled
                if (t.settings.multipleEff.active) {
                    t.intervalTimeInter = t.settings.auto.time / t.intervalContor;   
                }                
                t.startAuto();
            }
            
            // init caption for next slide
            if(t.propertyIsActive('caption')) {                
                t.caption(t.children[index2], 'on');
            }

            t.index  = index2;
			
            if (t.callbackFunction) {
                    t.callbackFunction.call(t.obj);
                    t.callbackFunction = null;
            } 
            
        },           
        
        /**
         * Returns the position of the element
         * 
         * param elem        =  the element that I what to positionate
         * param position    = direction (horizontal or vertical)
         * param where       =  direction of the custom position            
         */
        customPosition: function (elem, position, where) {
            
            var t = this, operation, pos;
            
            var width = t.sliderWidth;

            if (t.settings.animate.type == 'carousel') {
                width = parseInt(t.ul.css("width"));
            }
            
            if (typeof position === 'number') {
				if (where == 'vertical') {
					position = position * t.propV;
				} else if (where == 'horizontal') {
					position = position * t.propH;
				}
				
                return position;
            } else {
                if (position.search(/\+/) !== -1) {
                    pos = position.split('+');                    
                    position = pos[0];
                    operation = 'plus';
                } else if (position.search(/-/) !== -1) {
                    pos = position.split('-');                    
                    position = pos[0];
                    operation = 'minus';
                }
                
            }

            switch (position) {
                case 'middle':
                    if (where == 'vertical') {
                        position = parseInt((t.sliderHeight - elem.outerHeight(true)) / 2);
                    } else {
                        position = parseInt((width - elem.outerWidth(true)) / 2);
                    }
                    break;

                case 'start':
                    if (where == 'vertical') {
                        position = -elem.outerHeight(true);
                    } else {
                        position = -elem.outerWidth(true);
                    }
                    break;

                case 'end':
                    if (where == 'vertical') {
                        position = parseInt(t.sliderHeight);
                    } else {
                        position = parseInt(width);
                    }
                    break;
            }
            
            if (operation == 'plus') {
                position += parseInt(pos[1]);
            } else if (operation == 'minus') {
                position -= parseInt(pos[1]);
            }            
            
            return position;
        },
        
        /**
         * If a property is enabled or disabled
         * 
         * param property = name of the property that I will check
         */
        propertyIsActive: function (property) {
            
            var t = this;
                        
            if (property == 'caption') {
                if (t.settings.caption == false || ((t.settings.animate.type == 'sliderHorizontal' || t.settings.animate.type == 'sliderVertical' ) && t.settings.animate.perPage != 1)) {
                    return false;
                } else if (t.settings.caption) {
                    return true;
                }
            } else if (property == 'touchNavigation') {
                if (t.settings.animate.type == 'carousel' || t.settings.touchNavigation == false || ((t.settings.animate.type == 'sliderHorizontal' || t.settings.animate.type == 'sliderVertical' ) && t.settings.animate.perPage != 1)) {
                    return false;
                } else if (t.settings.touchNavigation) {
                    return true;
                }
            } else if (property == 'nav') {
                if (t.settings.animate.type == 'carousel' || t.settings.nav.active == false || ((t.settings.animate.type == 'sliderHorizontal' || t.settings.animate.type == 'sliderVertical' ) && t.settings.animate.perPage != 1)) {
                    return false;
                } else if (t.settings.nav.active) {
                    return true;
                }
            } else if (property == 'navImages') {
                if (t.settings.animate.type == 'carousel' || t.settings.nav.active == false || t.settings.nav.type != 'images' || ((t.settings.animate.type == 'sliderHorizontal' || t.settings.animate.type == 'sliderVertical' ) && t.settings.animate.perPage != 1)) {
                    return false;
                } else if (t.settings.nav.active && t.settings.nav.type == 'images') {
                    return true;
                }
            }
        },
        
        /**
         * Crop and resize an image
         * param src = path to source image
         * param width = width that I want for image
         * param width = height that I want for image
         */
        cropResizeImage: function (src, width, height) {

            var img = new Image(), widthImg, heightImg, propWidth, propHeight;

            img.src = src;

            widthImg    = img.width;
            heightImg   = img.height;

            propWidth   = widthImg / width;
            propHeight  = heightImg / height;

            if (propWidth < 1 || propHeight < 1) {
                if (widthImg > width) {
                    img.style.marginLeft = -Math.floor((widthImg - width) / 2) + "px";
                } else if (widthImg < width) {
                    img.style.marginLeft = Math.floor((width - widthImg) / 2) + "px";
                }

                if (heightImg > height) {
                    img.style.marginTop = -Math.floor((heightImg - height) / 2) + "px";
                } else if (heightImg < height) {
                    img.style.marginTop = Math.floor((height - heightImg) / 2) + "px";
                }
            } else if (propWidth > propHeight) {
                img.width = Math.ceil(widthImg / propHeight);
                img.height = Math.ceil(heightImg / propHeight);

                img.style.marginLeft = -Math.floor((widthImg / propHeight - width) / 2) + "px";
            } else if (propHeight > propWidth) {
                img.width = Math.ceil(widthImg / propWidth);
                img.height = Math.ceil(heightImg / propWidth);

                img.style.marginTop = -Math.floor((heightImg / propWidth - height) / 2) + "px";
            } else {
                img.width = Math.ceil(widthImg / propWidth);
                img.height = Math.ceil(heightImg / propHeight);
            }

            return img;
        },        
        
        /**
         * No effect
         * 
         * param elem1   = the current slide
         * param elem2	= the next slide
         */
        noEffect: function (index1, index2, direction) {
            var t = this;
            
            // disable multiple effects
            t.off(index1, index2);

            t.children[index2].addClass('active3');
            t.children[index1].removeClass('active3');

            // enable efects
            t.on(index2);
        },   
        
        /**
         * Fade (cinematic) effect
         * 
         * param elem1   = the current slide
         * param elem2	= the next slide
         */
        fade: function (index1, index2, direction) {    
            
            var t = this;
            
            // disable multiple effects
            t.off(index1, index2);

            var elem1 = t.children[index1], elem2 = t.children[index2];

            elem1.siblings().css({
                opacity:0
            });

            elem2.addClass('active2');

            elem1.fadeTo(t.settings.animate.speed, 0,
                function () {
                    elem1.removeClass('active3');
                    elem2.addClass('active3').removeClass('active2');
                    elem2.fadeTo(t.settings.animate.speed, 1, function () {                            
                        t.ul.children().removeAttr('style');

                        // enable efects
                        t.on(index2);
                    });	
                });
        },            
        
        /**
         * CrossFade effect
         * 
         * param elem1	- the current slide
         * param elem2	- the next slide
         */
        crossFade: function (index1, index2, direction) {
            
            var t = this;
                        
            // disable multiple effects
            t.off(index1, index2);
            
            var elem1 = t.children[index1], elem2 = t.children[index2];

            elem2.addClass('active2');

            elem1.fadeTo(t.settings.animate.speed, 0,
                function () {
                    elem1.removeClass('active3').removeAttr('style');
                    elem2.addClass('active3').removeClass('active2');

                    // enable efects
                    t.on(index2);
                });
        },        
        
        /**
         * Slider horizontal effect
         * 
         * param elem1	- the current slide
         * param elem2	- the next slide
         */
        sliderHorizontal: function (index1, index2, direction) {
            
            var t = this;
            
            // disable multiple effects
            t.off(index1, index2);

            var elem1 = t.children[index1], elem2 = t.children[index2], left;

            // for next direction
            if (direction == 'next') {
                left = t.widthContainer;            
            } else { // for prev direction
                left = -t.widthContainer;
            }

            // move the elem2 & add class .activ2
            elem2.addClass('active2').css({
                left: left
            });

            var inter_width = (parseFloat(t.ul.css("left")))? parseFloat(t.ul.css("left")) : 0;

            t.ul.animate({
                left: -left / t.settings.animate.perPage + inter_width
            }, t.settings.animate.speed, t.settings.animate.easing, //move the ul
            function () {
                if (-parseFloat(t.ul.css("left")) == left) {
                    t.ul.css({
                        left: 0
                    });

                    elem1.removeClass('active3');

                    elem2.css({
                        left: 0
                    }).removeClass('active2')
                    .addClass('active3');
                } else {
                    index2 = index1;
                }

                // enable efects
                t.on(index2); 
            } 
            );

        },
        
        /**
         * Slider vertical effect
         * 
         * param elem1	- the current slide
         * param elem2	- the next slide
         */
        sliderVertical: function (index1, index2, direction) {
            
            var t = this;
            
            // disable multiple effects
            t.off(index1, index2);

            var elem1 = t.children[index1], elem2 = t.children[index2], top;

            // for next direction
            if (direction == 'next') {
                top = t.heightContainer;            
            } else { // for prev direction
                top = -t.heightContainer;
            }

            // move the elem2
            elem2.addClass('active2').css({
                top: top
            });

            var inter_height = (parseFloat(t.ul.css("top")))? parseFloat(t.ul.css("top")) : 0;

            // move the ul
            t.ul.animate({
                top: -top / t.settings.animate.perPage + inter_height
            }, t.settings.animate.speed, t.settings.animate.easing,
            function () {
                if (-parseFloat(t.ul.css("top")) == top) {
                    t.ul.css({
                        top: 0
                    });

                    elem1.removeClass('active3');

                    elem2.css({
                        top: 0
                    }).removeClass('active2')
                    .addClass('active3');
                } else {
                    index2 = index1;
                }
                // enable efects
                t.on(index2);
            }
            );
        },               
        /**
         * The carousel effect
         * 
         * param index1 = the current slide
         * param index2 = the next slide
         * param direction = direction of the transition
         */
        carousel: function (index1, index2, direction) {
            
            var t = this;
            
            // disable multiple effects
            t.off(index1, index2); 

            var dirr, deplasare, i, 
                curr,
                elem1   = t.children[index1],
                elem2   = t.children[index2],
                arr     = [],
                car_nr2 = Math.floor(t.settings.animate.car_nr / 2),
                // the position where the slider start
                start   = (index2 - car_nr2 >= 0)? index2 - car_nr2 : t.ul_nr + index2 - car_nr2,
                // to now when the effect is finished 
                eff_on  = 0,          
                // contor that hold the variable to manipulate the <li>
                contor  = 9 - car_nr2,
                posL    = 0,
                opacity = 0;

            // add class active3 on the elem2 slide
            elem2.addClass('active3');
            // remove class active3 on the current slide
            elem1.removeClass('active3');

            if (index1 > t.ul_nr - 1 - car_nr2 && index2 < car_nr2) {
                direction = 'next';
            } else if (index2 > t.ul_nr - 1 - car_nr2 && index1 < car_nr2) {
                direction = 'prev';
            }

            if (direction == 'next') {
                // direction right
                dirr        = 1;
                // deplacement
                deplasare   = index2 - index1;

                if (deplasare < 0) {
                    deplasare = t.ul_nr - index1 + index2;
                }
            } else { // prev
                // direction right
                dirr        = 0;
                // deplacement
                deplasare   = index1 - index2;

                if (deplasare < 0) {
                    deplasare = t.ul_nr - index2 + index1;
                }
            }

            // for direction right
            if (dirr) {
                start = (start - deplasare >= 0)? start - deplasare: t.ul_nr + start - deplasare; // the position left where the slider start
            }

            for (i = 0; i < t.settings.animate.car_nr + deplasare; i++) {
                arr.push(start);

                if (start >= t.ul_nr - 1) {
                    start = 0;
                } else {
                    start++;
                }
            }

            // values used to align the <li> verticaly
            var marginTop   = [5, 6, 7, 7.5, 7.7, 7.8, 7.9, 7.92, 7.94, 7.96, 7.98],
                kk          = car_nr2;

            var opacityLi = 0;
            
            for (i = 0; i < arr.length; i++) {
                curr = t.children[arr[i]];

                if (dirr) { // to right

                    if (i < deplasare) {
                        opacityLi = 0;
                    } else {

                        if (i <= car_nr2 + deplasare) {
                            posL += t.sliderWidth * contor / 20;
                            contor++;
                            kk--;
                            opacity = contor / 10;
                        } else if(i >  car_nr2 + deplasare) {
                            posL += t.sliderWidth * (contor + 1) / 20;
                            contor--;
                            kk++;
                            opacity = contor / 10;
                        }

                        opacityLi = 1;

                        if (i >= arr.length - deplasare) {
                            curr.show();

                            curr.css({
                                left: t.ul.width() - (9 - car_nr2) * t.sliderWidth / 10
                            });
                        }
                    }

                } else { 
                    if (i <= car_nr2) {
                        posL += t.sliderWidth * contor / 20;
                        contor++;
                        kk--;
                        opacity = contor / 10;
                    } else if (i >  car_nr2) {
                        posL += t.sliderWidth * (contor + 1) / 20;
                        contor--;
                        kk++;
                        opacity = contor / 10;
                    }

                    opacityLi = 1;
                    if (i >= t.settings.animate.car_nr) {
                        opacityLi = 0;
                    }
                    if (i < deplasare) {
                        curr.css({
                            left: 0
                        });

                        curr.show();
                    }
                }

                var r = setTimeout(function () {

                    var contorIn = 10 - car_nr2, u; 

                    for (u = 0; u < arr.length; u++) {
                        t.children[arr[u]].css({
                            zIndex: contorIn
                        });

                        if (dirr) {
                            if (u < car_nr2 + deplasare) {
                                contorIn++;
                            } else if(u >=  car_nr2 + deplasare) {
                                contorIn--;
                            }
                        } else {
                            if (u < car_nr2) {
                                contorIn++;
                            } else if(u >=  car_nr2) {
                                contorIn--;
                            }
                        }
                    }

                }, t.settings.animate.speed / 3.5);
                
                if (typeof marginTop[kk] === "undefined") marginTop[kk] = 0;
                
                $(function () {   
                    
                    // update <li> position
                    curr.animate({ 
                        width:      t.sliderWidth * contor / 10,
                        height:     t.sliderHeight * contor / 10,
                        left:       posL,
                        opacity:    opacityLi,
                        marginTop:  (t.sliderHeight - t.sliderHeight * contor / 10) * (marginTop[kk] / 10) // align vertically
                    }, t.settings.animate.speed);
                    
                    // update position of images
                    curr.find('img').animate({
                        width:	t.sliderWidth * contor / 10,
                        height: 	t.sliderHeight * contor / 10,
                        opacity:	opacity
                    }, t.settings.animate.speed,
                        function () {
                            
                            eff_on++;
                            if (eff_on == arr.length) {
                                if (dirr) {
                                    for (i = 0; i < deplasare; i++) {
                                        t.children[arr[i]].hide();
                                    }
                                } else { // to left
                                    for (i = t.settings.animate.car_nr; i < arr.length; i++) {
                                        t.children[arr[i]].hide();
                                    }
                                }
                                t.on(index2);
                            }                            
                        }                        
                    );                    
                });                
            }
        },        
        
        /**
         * Square effect
         * 
         * param elem1       = the current slide
         * param elem2       = the next slide
         * param direction   = direction of the transition
         */
        square: function (index1, index2, direction) {
            
            var t = this;
            
            // disable multiple effects
            t.off(index1, index2); 

            var elem1           = t.children[index1],
                elem2           = t.children[index2],
                // width of one square
                dim_w           = Math.ceil(t.widthContainer / t.settings.animate.cols),
                // height of one square
                dim_h           = Math.ceil(t.heightContainer / t.settings.animate.rows),
                animateEffects  = {}, i;

             // buil the blocks
            t[t.settings.animate.position[0]](elem1.html(), dim_w, dim_h, t.settings.animate.position[1]);

            // add class active2 on the next slide
            elem2.addClass('active3');
            
            // remove class active3 on the current slide
            elem1.removeClass('active3');

            // check what effects is enabled
            if ($.inArray('fade', t.settings.animate.effect) != -1) {
                animateEffects.opacity = 0;
            }

            if ($.inArray('slideUp', t.settings.animate.effect) != -1) {
                animateEffects.height = 0;
            }

            if ($.inArray('slideUpLeft', t.settings.animate.effect) != -1) {
                animateEffects.height = 0;
                animateEffects.width = 0;
            }

            if ($.inArray('slideUpRight', t.settings.animate.effect) != -1) {
                animateEffects.height = 0;
                animateEffects.width = 0;
                animateEffects.marginLeft = dim_w;
            }

            if ($.inArray('slideDown', t.settings.animate.effect) != -1) {
                animateEffects.marginTop = dim_h;
                animateEffects.height = 0;
            }

            if ($.inArray('slideDownLeft', t.settings.animate.effect) != -1) {
                animateEffects.marginTop = dim_h;
                animateEffects.height = 0;
                animateEffects.width = 0;
            }

            if ($.inArray('slideDownRight', t.settings.animate.effect) != -1) {
                animateEffects.marginTop = dim_h;
                animateEffects.marginLeft = dim_w;
                animateEffects.height = 0;
                animateEffects.width = 0;
            }

            if ($.inArray('slideLeft', t.settings.animate.effect) != -1) {
                animateEffects.width = 0;
            }

            if ($.inArray('slideRight', t.settings.animate.effect) != -1) {
                animateEffects.width = 0;
                animateEffects.marginLeft = dim_w;
            }

            if ($.inArray('slideHCenter', t.settings.animate.effect) != -1) {
                animateEffects.width = 0;
                animateEffects.marginLeft = parseInt(dim_w/2, 10);
            }

            if ($.inArray('slideVCenter', t.settings.animate.effect) != -1) {
                animateEffects.height = 0;
                animateEffects.marginTop = parseInt(dim_h/2, 10);
            }

            if ($.inArray('slideCenter', t.settings.animate.effect) != -1) {
                animateEffects.width = 0;
                animateEffects.marginLeft = parseInt(dim_w/2, 10);
                animateEffects.height = 0;
                animateEffects.marginTop = parseInt(dim_h/2, 10);
            }

            if ($.inArray('moveTop', t.settings.animate.effect) != -1) {
                animateEffects.top = -dim_h;
            }
            
            if ($.inArray('moveLeft', t.settings.animate.effect) != -1) {
                animateEffects.left = -dim_w;
            }
            
            if ($.inArray('moveRight', t.settings.animate.effect) != -1) {
                animateEffects.left = t.widthContainer;
            }
            
            if ($.inArray('moveBottom', t.settings.animate.effect) != -1) {
                animateEffects.top = t.heightContainer;
            }

            var r,
                q       = 0,
                end     = 0,                    
                blocks  = t.ul.find('.block'),
                alter   = true;

            for (i = 0; i < t.settings.animate.cols * t.settings.animate.rows; i++) {
                
                if ($.inArray('slideRand', t.settings.animate.effect) != -1) {
                    
                    if (animateEffects.opacity == 0) {
                        animateEffects = {};
                        animateEffects.opacity = 0;
                    } else {
                        animateEffects = {};
                    }

                    q++;

                    if ((t.settings.animate.cols % 2 == 0) && (i % t.settings.animate.cols == 0) && (i != 0)) {
                        q--;
                    }

                    r = (q % 2 == 0)? Math.ceil(Math.random()*2) : Math.ceil(Math.random()*2 + 2);

                    if (r == 1) {
                        animateEffects.height = 0; // slideUp
                    } else if (r == 2) {
                        animateEffects.marginTop = dim_h; // slideDown
                        animateEffects.height = 0; // slideDown
                    } else if (r == 3) {
                        animateEffects.width = 0; // slideLeft
                    } else if (r == 4) {
                        animateEffects.width = 0; // slideRight
                        animateEffects.marginLeft = dim_w; // slideRight
                    }
                } else if ($.inArray('slideAlternativeV', t.settings.animate.effect) != -1) {
                    
                    if (animateEffects.opacity == 0) {
                        animateEffects = {};
                        animateEffects.opacity = 0;
                    } else {
                        animateEffects = {};
                    }                    
                    
                    animateEffects.height = 0;

                    if (alter) {
                        alter = false;
                    } else {
                        animateEffects.marginTop = dim_h;
                        alter = true;
                    }
                } else if ($.inArray('slideAlternativeH', t.settings.animate.effect) != -1) {
                    
                    if (animateEffects.opacity == 0) {
                        animateEffects = {};
                        animateEffects.opacity = 0;
                    } else {
                        animateEffects = {};
                    }                    
                                        
                    animateEffects.width = 0;

                    if (alter) {
                        alter = false;
                    } else {
                        animateEffects.marginLeft = dim_w;
                        alter = true;
                    }
                }
                
                // make the effect and delete the blocks
                blocks.eq(i).delay(t.settings.animate.delay * i).animate(animateEffects, t.settings.animate.speed, t.settings.animate.easing, function () {
                    if (++end == t.settings.animate.cols * t.settings.animate.rows) {
                        blocks.remove();
                        t.on(index2);
                    }
                });
            }
        },            
        
        /**
         * Liniar effect
         * 
         * param elemHTML    = the current slide
         * pram dim_w        = block width
         * param dim_h       = blocks height
         * param direction   = direction of the effect
         */
        liniarSquare: function (elemHTML, dim_w, dim_h, direction) {
            
            var t = this;
            
            var r, c, dir1, dir2, blocks = '', i, j;

            if (direction == 'rtl' || direction == 'ltr') {
                dir1 = t.settings.animate.cols;
                dir2 = t.settings.animate.rows;           
            } else {
                dir1 = t.settings.animate.rows;
                dir2 = t.settings.animate.cols;
            }

            for (i = 0; i < dir1; i++) {
                for (j = 0; j < dir2; j++) {
                    switch (direction) {
                        case 'ltr': // left to right squares
                            r = j;
                            c = i;
                            break;

                        case 'rtl': // right to left squares
                            r = j;
                            c = t.settings.animate.cols - 1 - i;
                            break;

                        case 'ttb': // top to bottom squares
                            r = i;
                            c = j;
                            break;

                        default: // btt bottom to top squares
                            r = t.settings.animate.rows - 1 - i;
                            c = j;
                    }

                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + r * dim_h + 'px;left:' + c * dim_w + 'px"><li style="top:-' + r * dim_h +'px;left:-' + c * dim_w + 'px">' + elemHTML + '</li></div>';

                }
            }
            
            t.ul.append(blocks);
        },            
        
        /**
         * Random effect
         * 
         * param elemHTML    = the current slide
         * pram dim_w        = block width
         * param dim_h       = blocks height
         * param direction   = direction of the effect
         */
        randomSquare: function (elemHTML, dim_w, dim_h, direction) {
            
            var t = this;
            
            var block = [], blocks = '', i, j;

            for (i = 0; i < t.settings.animate.cols; i++) {
                for (j = 0; j < t.settings.animate.rows; j++) {
                    block.push(new Array(j, i));
                }
            }

            // shuffle the array blocks
            for (i = 0; i < block.length; i++) {
                var rand        = Math.floor(Math.random() * (block.length)),
                    temp        = block[rand];
                    block[rand] = block[i];
                    block[i]    = temp;
            }           

            for (i = 0; i < block.length; i++) {
                blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + block[i][0] * dim_h + 'px;left:' + block[i][1] * dim_w + 'px"><li style="top:-' + block[i][0] * dim_h +'px;left:-' + block[i][1] * dim_w + 'px">' + elemHTML + '</li></div>';
            }

            t.ul.append(blocks);
        },            
        
        /**
         * Margin to center effect
         * 
         * param elemHTML    = the current slide
         * pram dim_w        = block width
         * param dim_h       = blocks height
         * param direction   = direction of the effect (horizontal or vertical)
         */
        marginToCenterSquare: function (elemHTML, dim_w, dim_h, direction) {
            
            var t = this;
            
            var r, c, blocks = '', dir1, dir2, i, j, contor, bool;

            // for next direction
            if (direction == 'horizontal') {
                dir1 = t.settings.animate.cols;
                dir2 = t.settings.animate.rows;
            // for prev direction
            } else {
                dir1 = t.settings.animate.rows;
                dir2 = t.settings.animate.cols;
            }

            bool = true;

            for (i = 0, contor = 0; contor < dir1; contor++) {
                for (j = 0; j < dir2; j++) {                
                    // horizontal effect
                    if (direction == 'horizontal') { 
                        r = j;
                        c = i;
                    } else { // vertical effect
                        r = i;
                        c = j;
                    }

                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + r * dim_h + 'px;left:' + c * dim_w + 'px"><li style="top:-' + r * dim_h +'px;left:-' + c * dim_w + 'px">' + elemHTML + '</li></div>';
                }
                if (bool) {
                    i = dir1 - Math.ceil(contor/2) - 1;
                    bool = false;
                } else {
                    i = Math.ceil(contor/2);
                    bool = true;
                }
            }

            t.ul.append(blocks); // make the blocks
        },            
        
        /**
         * Center to margin effect
         * 
         * param elemHTML    = the current slide
         * pram dim_w        = block width
         * param dim_h       = blocks height
         * param direction   = direction of the effect (horizontal or vertical)
         */
        centerToMarginSquare: function (elemHTML, dim_w, dim_h, direction) {
            
            var t = this;
            
            var r, c, blocks = '', dir1, dir2, i, j, center, bool, contor;

            // for next direction
            if (direction == 'horizontal') {
                dir1 = t.settings.animate.cols;
                dir2 = t.settings.animate.rows;            
            } else { // for prev direction
                dir1 = t.settings.animate.rows;
                dir2 = t.settings.animate.cols;
            }

            center = Math.floor(dir1 / 2);
            bool = true;

            for (i = center, contor = 0; contor < dir1; contor++) {
                for (j = 0; j < dir2; j++) {                        
                    // horizontal effect
                    if (direction == 'horizontal') { 
                        r = j;
                        c = i;
                    // vertical effect
                    } else { 
                        r = i;
                        c = j;
                    }

                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + r * dim_h + 'px;left:' + c * dim_w + 'px"><li style="top:-' + r * dim_h +'px;left:-' + c * dim_w + 'px">' + elemHTML + '</li></div>';

                }

                if (bool) {
                    i = center - Math.ceil((contor + 1)/2);
                    bool = false;
                } else {
                    i = center + Math.ceil((contor + 1)/2);
                    bool = true;
                }
            }

            t.ul.append(blocks);
        },            
        
        /**
         * Sinus effect
         * 
         * param elemHTML    = the current slide
         * pram dim_w        = block width
         * param dim_h       = blocks height
         * param direction   = direction of the effect (horizontal or vertical)
         */
        sinusSquare: function (elemHTML, dim_w, dim_h, direction) {
            
            var t = this;
            
            var r, c, blocks = '', dir1, dir2, i, j, posSinus = 0, bool = true, m;

            // for next direction
            if (direction == 'horizontal') {
                dir1 = t.settings.animate.rows;
                dir2 = t.settings.animate.cols;            
            } else { // for prev direction
                dir1 = t.settings.animate.cols;
                dir2 = t.settings.animate.rows;
            }

            for (i = posSinus; i <= dir1; i++) {
                for (j = 0, m = posSinus; j < dir2; j++) {                        
                    // horizontal effect
                    if (direction == 'horizontal') {
                        r = m;
                        c = i;                    
                    } else { // vertical effect
                        r = i;
                        c = m;
                    }

                    m = (posSinus - j > 0)? posSinus - j - 1 : j + 1;                    
                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + c * dim_h + 'px;left:' + r * dim_w + 'px"><li style="top:-' + c * dim_h +'px;left:-' + r * dim_w + 'px">' + elemHTML + '</li></div>';
                }

                if (bool) {
                    posSinus = dir2 - 1;
                    bool = false;
                } else {
                    posSinus = 0;
                    bool = true;
                }
            }

            t.ul.append(blocks); // make the blocks
        },  
        
        /**
         * Diagonal square effect
         * 
         * param elemHTML    = the current slide
         * pram dim_w        = block width
         * param dim_h       = blocks height
         * param direction   = direction of the effect (horizontal or vertical)
         */        
        diagonalSquare: function (elemHTML, dim_w, dim_h, direction) {
            
            var t = this;
            
            var blocks = '', i, n, m, k, block = [], blocks_len;

            // left-top direction
            if (direction == 'LT') {
                m = 0;

                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = n;

                    if (n > t.settings.animate.rows) {
                        k = t.settings.animate.rows;
                    }

                    if (n > t.settings.animate.cols) { 
                        m++;
                    }

                    for (i = k-1; i >= m; i--) {
                        block.push(new Array(i, 0));
                    }
                }

                blocks_len = 0;

                m = 0;
                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = n;

                    if (n > t.settings.animate.cols) {
                        k = t.settings.animate.cols;
                    } 

                    if (n > t.settings.animate.rows) {
                        m++;  
                    } 

                    for (i = m; i < k; i++) {
                        block[blocks_len][1] = i;
                        blocks_len++;
                    }
                }

                for (i = 0; i < block.length; i++) {
                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + block[i][0] * dim_h + 'px;left:' + block[i][1] * dim_w + 'px"><li style="top:-' + block[i][0] * dim_h +'px;left:-' + block[i][1] * dim_w + 'px">' + elemHTML + '</li></div>';
                }
                
            // right-top direction
            } else if (direction == 'RT') {
                
                block   = [];                    
                m       = t.settings.animate.cols;

                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = t.settings.animate.cols - n;

                    if (n > t.settings.animate.rows) {
                        m--;
                    } 
                    if (n > t.settings.animate.cols) {
                        k = 0;
                    }

                    for (i = k; i < m; i++) {
                        block.push(new Array(0, i));
                    }
                }

                blocks_len = 0;

                m = 0;
                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = n;

                    if (n > t.settings.animate.rows) {
                        k = t.settings.animate.rows;
                    }

                    if (n > t.settings.animate.cols) {
                        m++;
                    }

                    for (i = m; i < k; i++) {
                        block[blocks_len][0] = i;
                        blocks_len++;
                    }
                }

                for (i = 0; i < block.length; i++) {
                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + block[i][0] * dim_h + 'px;left:' + block[i][1] * dim_w + 'px"><li style="top:-' + block[i][0] * dim_h +'px;left:-' + block[i][1] * dim_w + 'px">' + elemHTML + '</li></div>';
                }

            } else if(direction == 'LB') {
                
                block = [];
                m = t.settings.animate.cols;

                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = t.settings.animate.cols - n;

                    if (n > t.settings.animate.rows) {
                        m--;
                    }

                    if (n > t.settings.animate.cols) {
                        k = 0;
                    }

                    for (i = k; i < m; i++) {
                        block.push(new Array(i, 0));
                    }
                }
                blocks_len = 0;

                m = 0;
                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = n;

                    if (n > t.settings.animate.rows) {
                        k = t.settings.animate.rows;
                    }

                    if (n > t.settings.animate.cols) {
                        m++;
                    }

                    for (i = m; i < k; i++) {
                        block[blocks_len][1] = i;
                        blocks_len++;
                    }
                }

                for (i = 0; i < block.length; i++) {
                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + block[i][0] * dim_h + 'px;left:' + block[i][1] * dim_w + 'px"><li style="top:-' + block[i][0] * dim_h +'px;left:-' + block[i][1] * dim_w + 'px">' + elemHTML + '</li></div>';
                }
            // right-bottom direction
            } else if(direction == 'RB') {
                
                block = [];
                m = t.settings.animate.rows;

                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = t.settings.animate.rows - n;

                    if (n > t.settings.animate.rows) {
                        k = 0;
                    }

                    if (n > t.settings.animate.cols) {
                        m--;
                    }

                    for (i = k; i < m; i++) {
                        block.push(new Array(i, 0));
                    }
                }
                blocks_len = 0;

                m = t.settings.animate.cols;
                for (n = 1; n < t.settings.animate.cols + t.settings.animate.rows; n++) {
                    k = t.settings.animate.cols - n;

                    if (n > t.settings.animate.cols) {
                        k = 0;
                    }

                    if (n > t.settings.animate.rows) {
                        m--;
                    }

                    for (i = m - 1; i >= k; i--) {
                        block[blocks_len][1] = i;
                        blocks_len++;
                    }
                }

                for (i = 0; i < block.length; i++) {
                    blocks += '<div class="block" style="width:' + dim_w + 'px;height:' + dim_h + 'px;top:' + block[i][0] * dim_h + 'px;left:' + block[i][1] * dim_w + 'px"><li style="top:-' + block[i][0] * dim_h +'px;left:-' + block[i][1] * dim_w + 'px">' + elemHTML + '</li></div>';
                }
            }

            t.ul.append(blocks);
        }         
    };
    
    // PUBLIC METHODS
    var hotwp = {
        
        /**
         * Initialize slider
         */
        init: function (options, arg) {
    
            // Plugin default parameters
            var settings = {
                    mode:						'none', // set the slider mode: 'none', 'fullscreen', 'fullwidth'
					
                    arrows: {
                        next:                   true, // if the next button is active or not (true / false)
                        nextHorizontal:         25, // next button position horizontal (integer values | 'start' | 'end', | 'middle')
                        nextVertical:           403, // next button position vertical (integer values | 'start' | 'end', | 'middle')
                        prev:                   true, // if the prev button is active or not (true / false)
                        prevHorizontal:         25, // prev button position horizontal (integer values | 'start' | 'end', | 'middle')
                        prevVertical:           403 // prev button position vertical (integer values | 'start' | 'end', | 'middle')
                    },
					
                    nav: {
                        active:                 true,  // if the navigation is active or not (true / false)
                        type:                   'bullets', // navigation type ('bullets', 'numbers', 'images')
                        imagesDimension:        '100x100', // the images size for navigation type = 'images' ('WIDTHxHEIGHT')
                        navHorizontal:          96, // position horizontal of navigation (integer values | 'start' | 'end', | 'middle')
                        navVertical:            34,  // position vertical of navigation (integer values | 'start' | 'end', | 'middle')
                        thumbs:                 true, // if the thumbs is active or not (true / false)
                        thumbsDimension:        '100x100' // thumbs dimension ('WIDTHxHEIGHT')
                    },
					
                    auto: {
                        active:                 false, // enables / disable the autostart feature of the slider. (true / false)
                        time:                   3000, // you can set the delay of the slides. How much time pass until the next slide will apear. This time is set in milisecconds. 1000 milliseconds equals 1 second.
                        timer:                  'none', // type of timer: 'none', 'line', 'circular', 'numbers'
                        hoverStop:              true, // when user hovers the slider the slidings stops. (true / false)
                        posHorizontal:		567, // position horizontal of auto (integer values | 'start' | 'end', | 'middle')
                        posVertical:		50, // position vertical of auto (integer values | 'start' | 'end', | 'middle')
                        playPause:              true, // enables / disables the play / pause feature (true / false)
                        playPauseHover:         true, // if play / button is hover on slider (true / false)
                        playPauseHorizontal:    580, // position horizontal of play / pause (integer values | 'start' | 'end', | 'middle')
                        playPauseVertical:      62 // position vertical of play / pause (integer values | 'start' | 'end', | 'middle')
                    },
					
                    animate:{
                        type:                   'square',// effect type ('noEffect', 'sliderHorizontal', 'sliderVertical', 'fade', 'crossFade', 'square', 'carousel')
                        speed:                  1000, // slide transition speed in ms (1s = 1000ms)
                        position:               ['liniarSquare', 'rtl'],
                        effect:                 ['fade'], // effects available (see configurator on hotwp.net/zuper for more info)
                        cols:                   10, // numbers of cols (only integer values)
                        rows:                   1,  // numbers of rows (only integer values)
                        delay:                  20, // delay between square animation (only integer values)
                        easing:                 'swing', // type of easing
                        car_nr:                 7 // numbers of slide for carousel effect (only integer values)
                    },
					
                    multipleEff: {
                        active:                 false, // you can set on each slide different effects and you can randomize them (true / false)
                        random:                 false, // random the different effects
                        eff:                    [''] // put here the different effects here separated by commas.
                    },
                    order: {
                        random:                 false, // randomize the slides (true / false)
                        firstSlide:             1, // what slide will be first (integer values or 'middle')
                        startSlide:             1 // Set start slide index (integer values or 'middle')
                    },
					
                    caption:                    true, // add captions with simple text or HTML text (true / false)
					captionCallback:			function () {}, // function to reposition the captions when the slider dimension is change
                    touchNavigation:            true, // if the touch feature is active or not (true / false)
                    bgImageScaleAndCenter:      true, // scale image and center (true / false)
                    responsive:                 true, // responsive feature (true / false)
                    navigateOnHover:            true, // change the slide on hover 
                    navigateWithMouseWheel:     true
                };  
            
            var t = $(this), hwp;
            
            if (options) $.extend(settings, options);
            
            hwp = new zuperSlider(t, settings);
            
            t.data('zuperSlider', hwp);
			
			if ($.isFunction(arg)) {
				arg.call(t.obj);
			}	

        },
        
        /**
        * Trigger the next slide
        * 
	* arg = callback function or 'this' object of slider
        */
        nextItem: function (arg) {
            var t;

            if ($.isFunction(arg)) {
                    t = $(this).data('zuperSlider');
                    t.callbackFunction = arg;
            } else {
                    t = arg;
                    t.callbackFunction = null;
            }
            
            // disable multiple effects
            if (t.active) return false;

            var index1 = t.index, index2 = index1 + 1;

            if (t.settings.order.random) {
                index2 = t.randomSlide(index1);
            } else if (index2 > t.ul_nr - 1) {
                index2 = 0;
            }

            if (t.settings.multipleEff.active) t.multipleEffects(index2);

            // bulid the effects
            t[t.settings.animate.type](index1, index2, 'next');
        },
        
        /**
         * Trigger the previous slide
         * 
         * arg = callback function or 'this' object of slider
         */
        prevItem: function (arg) {
			var t;
			
			if ($.isFunction(arg)) {
				t = $(this).data('zuperSlider');
				t.callbackFunction = arg;
			} else {
				t = arg;
				t.callbackFunction = null;
			}
            
            // disable multiple effects
            if (t.active) return false;

            var index1 = t.index, index2 = index1 - 1;

            if (t.settings.order.random) {
                index2 = t.randomSlide(index1);
            } else if (index2 < 0) {
                index2 = t.ul_nr - 1;
            }

            if (t.settings.multipleEff.active) t.multipleEffects(index2);

            // build the effects
            t[t.settings.animate.type](index1, index2, 'prev');
        },   
        
        /**
         * Trigger a specific slide
         * 
         * index2 = index of slide
         * arg = callback function or 'this' object of slider
         */        
        jumpToItem: function (index2, arg) {
            var t;
			
			if (arg) {
			
				if ($.isFunction(arg)) {
					t = $(this).data('zuperSlider');
					t.callbackFunction = arg;
				} else {
					t = arg;
					t.callbackFunction = null;
				}	
				
			} else {
				t = $(this).data('zuperSlider');
			}
			
			
            if (!index2) {
                index2 = 0;
            }
            
            // disable multiple effects
            if (t.active) return false;

            var index1 = t.index, direction;

            if (index1 < index2) {
                direction = 'next';
            } else if (index1 > index2) {
                direction = 'prev';
            } else {
                return false;
            }

            if (t.settings.multipleEff.active ) t.multipleEffects(index2);

            // build the effects
            t[t.settings.animate.type](index1, index2, direction);
        },
        
        /**
         * Stop slideshow if this property is enabled
		 *
		 * arg = callback function 
         */
        stopSlideshow: function (arg) {
            
            var t = $(this).data('zuperSlider'),
                playPause = t.obj.find('.playPause'), runCallbackFunction = false;				
                        
            if (playPause.length) {
                if (playPause.hasClass('play')) {
                    playPause.trigger('click');
					runCallbackFunction = true;
                }
            } else {
                if (t.settings.auto.active && !t.flagStop) {
                    // pause the auto
                    t.flagStop = true;
                    clearInterval(t.run);
					runCallbackFunction = true;
                }                
            }   

			if ($.isFunction(arg) && runCallbackFunction) {
				arg.call(t.obj);
			}			
        },
        
        /**
         * Resume slideshow
		 *
		 * arg = callback function 
         */        
        resumeSlideshow: function (arg) {

            var t = $(this).data('zuperSlider'),
                playPause = t.obj.find('.playPause'), runCallbackFunction = false;

            if (playPause.length) {
                if (playPause.hasClass('pause')) {
                    playPause.trigger('click');
					runCallbackFunction = true;
                }
            } else {
                if (t.settings.auto.active && t.flagStop) {
                    // start the auto
                    t.flagStop = false;
                    t.startAuto();   
					runCallbackFunction = true;					
                }
            }   

			if ($.isFunction(arg) && runCallbackFunction) {
				arg.call(t.obj);
			}	
        },
        
        /**
         * Destroy the slider
		 *
		 * arg = callback function 
         */
        destroy: function (arg) {
            var t = $(this).data('zuperSlider');
            
            // unbind and delete all elements of slider
            if (t.settings.auto.active) {            
                clearInterval(t.run);             
                t.delayStop = true;
            }            

            t.obj.unbind();
            t.obj.parent().find('*').unbind();

            $(document).unbind(t.mousemove + ' ' + t.mouseup);
            
            $(window).unbind('resize.hs');

            t.obj.remove();
			
            if ($.isFunction(arg)) {
                    arg.call(t.obj);
            }			
        },
        
        /**
         * Start callback function for slides
         */
        startCallback: function () {
            var t = $(this).data('zuperSlider'), i, arg = arguments;
            
            if (arg.length < 1 || !$.isFunction(arg[0])) {
                return;
            } else if (arg.length == 1) {
                for (i = 0; i < t.ul_nr; i++) {
                    t.callbackFunctionItemsStart[i] = arg[0];
                }
            } else {
                for (i = 1; i < arg.length; i++) {
                    if (arg[i] == 0) continue;
                    t.callbackFunctionItemsStart[arg[i] - 1] = arg[0];
                    
                    if (t.index == arg[i] - 1) {
                        arg[0].apply(t);
                    }                    
                }                
            }            
        },
        
        /**
         * End callback function for slides
         */     
        endCallback: function () {
            var t = $(this).data('zuperSlider'), i, arg = arguments;
            
            if (arg.length < 1 || !$.isFunction(arg[0])) {
                return;
            } else if (arg.length == 1) {
                for (i = 0; i < t.ul_nr; i++) {
                    t.callbackFunctionItemsEnd[i] = arg[0];
                }
            } else {
                for (i = 1; i < arg.length; i++) {
                    if (arg[i] == 0) continue;
                    t.callbackFunctionItemsEnd[arg[i] - 1] = arg[0];                
                }                
            }
        }
    };   
    
    /**
     * jQuery plugin initializer
     */    
    $.fn.zuperSlider = function (arg) {
        var args  = arguments;
        
        return this.each(function () {
            
            // public method calling
            if (hotwp[arg]) {

                return hotwp[arg].apply(this, Array.prototype.slice.call(args, 1));

            } else if (typeof arg === 'object' || ! arg) {

                return hotwp.init.apply(this, args);

            } else {

                alert('Method ' +  arg + ' does not exist on jQuery.zuperSlider');
            }
            
        });
        
    };
})(jQuery);

// glider plugin (under development)
;(function ($, window) {

    'use strict';

    $.fn.glider = function (options) {

        var defaults = {
            itemsToShow: 4, // integer; the number of items that will be showing at a time
            controls: false, // boolean; displays paging arrows and slider handle
            storySummary: false, // boolean; animates story summary thumbmail overlay
            showCurrent: false, // boolean; displays border around item when anchor url is the same as current page
            playIcon: false // boolean; displays semi-transparent 'play' icon over item (used to indicate a video)
        };
        var o = $.extend(defaults, options);
        var container = this.children('ul');
        var items = container.children('li');
        var itemWidth = items.outerWidth(true);
        var itemCount = items.length;
        var containerWidth = itemWidth * itemCount;
        var slideMovement = 15;
        var bounds = {
            'left': 0,
            'right': -((itemWidth * itemCount) - container.outerWidth())
        };
        //var gliderType = this.attr('class').split(' ')[1];

        //mo.log(gliderType + '->' + containerWidth + ' items =  ' + itemCount + ' right edge = ' + bounds.right);

        // set width of container to make room for floats
        container.width(containerWidth);

        function moveItemsLeft() {
            if(container.position().left < bounds.left) {
                container.css({
                    left : container.position().left + slideMovement
                });
            }
        }

        function moveItemsRight() {
            if(container.position().left > bounds.right) {
                container.css({
                    left : container.position().left - slideMovement
                });
            }
        }

        // don't show the controls if all of the items are currently visible
        if (items.length <= o.itemsToShow) {
            o.controls = false;
        }

        if (o.playIcon) {
            items.find('.sliderThumbnailImage').append('<span />');
        }

        //
        if (o.controls) {

			// slider control dom elements
			var controlsContainer = $('<div class="sliderControls"></div>');
			var slideLeft = $('<a href="#" class="sliderPrevious"></a>');
			var slideRight = $('<a href="#" class="sliderNext"></a>');
			//var sliderHandle = $('<a href="#" class="sliderHandle"></a>');
			var slideSpeed = 30;
			var sliding;

            // add slider controls to dom
            this.after(controlsContainer.append(slideLeft,/*sliderHandle,*/slideRight));

            // left arrow handler
            slideLeft.on({
                click: function (e) {
                    e.preventDefault();
                },
                mousedown: function () {
                    sliding = window.setInterval(moveItemsLeft, slideSpeed);
                },
                mouseup: function () {
                    window.clearInterval(sliding);
                }
            });

            // right arrow handler
            slideRight.on({
                click: function (e) {
                    e.preventDefault();
                },
                mousedown: function () {
                    sliding = window.setInterval(moveItemsRight, slideSpeed);
                },
                mouseup: function () {
                    window.clearInterval(sliding);
                }
            });

        }



    };
})(jQuery, window);