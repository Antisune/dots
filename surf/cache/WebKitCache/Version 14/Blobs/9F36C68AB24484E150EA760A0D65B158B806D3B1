let serviceOption = {};
(function (serviceOption) {
    //For IE
    if (!String.prototype.includes) {
        String.prototype.includes = function (search, start) {
            'use strict';
            if (typeof start !== 'number') {
                start = 0;
            }

            if (start + search.length > this.length) {
                return false;
            } else {
                return this.indexOf(search, start) !== -1;
            }
        };
    }

    if (!Array.prototype.includes) {
        Object.defineProperty(Array.prototype, 'includes', {
            value: function (valueToFind, fromIndex) {

                if (this == null) {
                    throw new TypeError('"this" is null or not defined');
                }

                // 1. Let O be ? ToObject(this value).
                var o = Object(this);

                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;

                // 3. If len is 0, return false.
                if (len === 0) {
                    return false;
                }

                // 4. Let n be ? ToInteger(fromIndex).
                //    (If fromIndex is undefined, this step produces the value 0.)
                var n = fromIndex | 0;

                // 5. If n ≥ 0, then
                //  a. Let k be n.
                // 6. Else n < 0,
                //  a. Let k be len + n.
                //  b. If k < 0, let k be 0.
                var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

                function sameValueZero(x, y) {
                    return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
                }

                // 7. Repeat, while k < len
                while (k < len) {
                    // a. Let elementK be the result of ? Get(O, ! ToString(k)).
                    // b. If SameValueZero(valueToFind, elementK) is true, return true.
                    if (sameValueZero(o[k], valueToFind)) {
                        return true;
                    }
                    // c. Increase k by 1. 
                    k++;
                }

                // 8. Return false
                return false;
            }
        });
    }

    if (!Array.from) {
        Array.from = (function () {
            var toStr = Object.prototype.toString;
            var isCallable = function (fn) {
                return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
            };
            var toInteger = function (value) {
                var number = Number(value);
                if (isNaN(number)) { return 0; }
                if (number === 0 || !isFinite(number)) { return number; }
                return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var toLength = function (value) {
                var len = toInteger(value);
                return Math.min(Math.max(len, 0), maxSafeInteger);
            };

            // The length property of the from method is 1.
            return function from(arrayLike/*, mapFn, thisArg */) {
                // 1. Let C be the this value.
                var C = this;

                // 2. Let items be ToObject(arrayLike).
                var items = Object(arrayLike);

                // 3. ReturnIfAbrupt(items).
                if (arrayLike == null) {
                    throw new TypeError("Array.from requires an array-like object - not null or undefined");
                }

                // 4. If mapfn is undefined, then let mapping be false.
                var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                var T;
                if (typeof mapFn !== 'undefined') {
                    // 5. else
                    // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                    if (!isCallable(mapFn)) {
                        throw new TypeError('Array.from: when provided, the second argument must be a function');
                    }

                    // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                    if (arguments.length > 2) {
                        T = arguments[2];
                    }
                }

                // 10. Let lenValue be Get(items, "length").
                // 11. Let len be ToLength(lenValue).
                var len = toLength(items.length);

                // 13. If IsConstructor(C) is true, then
                // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
                // 14. a. Else, Let A be ArrayCreate(len).
                var A = isCallable(C) ? Object(new C(len)) : new Array(len);

                // 16. Let k be 0.
                var k = 0;
                // 17. Repeat, while k < len… (also steps a - h)
                var kValue;
                while (k < len) {
                    kValue = items[k];
                    if (mapFn) {
                        A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                    } else {
                        A[k] = kValue;
                    }
                    k += 1;
                }
                // 18. Let putStatus be Put(A, "length", len, true).
                A.length = len;
                // 20. Return A.
                return A;
            };
        }());
    }

    serviceOption.filterAddon = function (responseData, pn) {
        let result = { needDisplayed: [], canBeSelected: [], locked: [], selected: [], selectedWarranty: null };

        //only sort once
        if (this.addonOrderInit === undefined && responseData.addons != undefined && responseData.addons && responseData.addons.length > 1) {
            //set ISE as "ZZZ" then when sorting, it will be put in tail
            responseData.addons.map(function (m) {
                if (m.warrantyCode == "ISE") {
                    m.sortCode = "ZZZ"
                } else {
                    m.sortCode = m.warrantyCode
                }
            });
            //sort to make the UI consistent
            responseData.addons.sort(function (a, b) {
                if (a.sortCode < b.sortCode) {
                    return -1;
                }
                if (a.sortCode > b.sortCode) {
                    return 1;
                }
                return 0;
            });
            this.addonOrderInit = true;
        }
        let iseTerm = null;
        if (responseData && responseData.addons && responseData.addons.length > 0) {
            if (!pn || pn == "BASE") {
                result = _getAddonForCurrentWarranty(responseData);
                delete window["lastSelectedAddons"];
                delete window["lastSelectedWarrantyPn"];
            }
            else {
                let isWarranty = responseData.warranties.filter(function (warranty) { return warranty.partNumber == pn }).length > 0;
                if (isWarranty) {
                    //Double selected
                    if (window["lastSelectedWarrantyPn"] == pn) {
                        delete window["lastSelectedWarrantyPn"];
                        result = _getAddonForCurrentWarranty(responseData);
                    }
                    else {
                        window["lastSelectedWarrantyPn"] = pn;
                        result = _getAddonForSpecificWarranty(responseData, pn);
                    }

                    if (result.locked && result.locked.length > 0)
                        window["lastSelectedAddons"] = result.locked;
                    else
                        delete window["lastSelectedAddons"];
                }
                else {
                    result = window["lastSelectedWarrantyPn"] ? _getAddonForSpecificWarranty(responseData, window["lastSelectedWarrantyPn"]) : _getAddonForCurrentWarranty(responseData);
                    //Double selected
                    if (window["lastSelectedAddons"] && window["lastSelectedAddons"].includes(pn))
                        window["lastSelectedAddons"] = window["lastSelectedAddons"].filter(function (selectedAddon) { return selectedAddon != pn });
                    else {
                        if (window["lastSelectedAddons"] == null)
                            window["lastSelectedAddons"] = [];
                        window["lastSelectedAddons"].push(pn);
                    }
                }
            }
        }

        if (window["lastSelectedAddons"] && window["lastSelectedAddons"].length > 0) {
            let selectedDependencies = responseData.addons.filter(function (addon) {
                if (addon.dependencies) {
                    let include = false;

                    window["lastSelectedAddons"].concat(result.locked.map(function (lockedAddon) { return lockedAddon.partNumber })).some(function (selectedAddon) {
                        if (addon.dependencies.includes(selectedAddon))
                            include = true;

                        return include == true;
                    });

                    return include;
                }
                return false;
            });

            result.needDisplayed = result.needDisplayed.concat(selectedDependencies);
            result.canBeSelected = result.canBeSelected.concat(selectedDependencies);

            //Refresh Locked information because the length of time may change
            selectedDependencies.map(function (selectedAddon) {
                let addons = result.locked.filter(function (lockedAddon) { return lockedAddon.warrantyCode == selectedAddon.warrantyCode });
                if (addons && addons.length > 0) {
                    if (selectedAddon.unitTerm > addons[0].unitTerm) {
                        addons[0].unitTerm = selectedAddon.unitTerm;
                        addons[0].partNumber = selectedAddon.partNumber;
                    }
                }
            });

            //Time Length of Currently Selected Warranty
            let warrantyUnitTerm = window["lastSelectedWarrantyPn"] ? responseData.warranties.filter(function (warranty) { return warranty.partNumber == window["lastSelectedWarrantyPn"] })[0].unitTerm : responseData.ibase.currentEffectiveWarranty.duration;
            //Select 4Y warranty
            //Can buy 3Y SB
            //So can buy 3Y ISE
            //Buy 4Y ADP at this time
            //Can buy 4Y ISE
            //So Only one ISE needs to be retained
            //Only ISE is special, so special handling
            if (selectedDependencies.length == 1 && selectedDependencies[0].warrantyCode == "ISE" && selectedDependencies[0].unitTerm < warrantyUnitTerm)
                iseTerm = selectedDependencies[0].unitTerm;
        }

        result.locked = _filterArray(result.locked);
        result.needDisplayed = _filterArray(result.needDisplayed, iseTerm);
        result.canBeSelected = _filterArray(result.canBeSelected, iseTerm);
        result.needDisplayed = _distinct(result.needDisplayed.concat(result.canBeSelected));

        result.selectedWarranty = window["lastSelectedWarrantyPn"] ? window["lastSelectedWarrantyPn"] : "BASE";
        result.selected = window["lastSelectedAddons"] && window["lastSelectedAddons"].length > 0 ? window["lastSelectedAddons"] : [];
        result.selected = result.selected.filter(function (item) { return result.needDisplayed.includes(item) });
        if (result.locked && result.locked.length > 0) {
            result.selected = _distinct(result.selected.concat(result.locked));
            result.canBeSelected = result.canBeSelected.filter(function (item) { return !result.locked.includes(item) });
        }
        result.selected = _clearInvalidSelected(responseData.addons, result.selected, result.selectedWarranty);

        //Fix UPS-1518
        let ibaseIse = responseData.ibase.baseWarranties.concat(responseData.ibase.upgradeWarranties).filter(function (ibaseAddon) { return ibaseAddon.deliveryType == "ISE" });
        if (ibaseIse && ibaseIse.length > 0) {
            let maxDate = Math.max.apply(Math, ibaseIse.map(function (ise) { return new Date(ise.endDate) }));
            let ise = ibaseIse.filter(function (ise) { return new Date(ise.endDate).getTime() == maxDate })[0];
            if (new Date(ise.endDate).getTime() > new Date().getTime()) {
                let lockedIse = responseData.addons.filter(function (addon) { return result.locked.includes(addon.partNumber) }).filter(function (lockedAddon) { return lockedAddon.warrantyCode == "ISE" });
                if ((!lockedIse || lockedIse.length == 0) && result.selected.length > 0) {
                    let unitTerm = responseData.addons.filter(function (addon) { return addon.partNumber == result.selected[0] })[0].unitTerm;
                    let ise = responseData.addons.filter(function (addon) { return addon.warrantyCode == "ISE" && addon.unitTerm == unitTerm });
                    if (ise && ise.length > 0 && result.needDisplayed.includes(ise[0].partNumber)) {
                        result.locked.push(ise[0].partNumber);
                        result.selected.push(ise[0].partNumber);
                    }
                }
            }
        }

        //Reset last selected addons
        window["lastSelectedAddons"] = result.selected;

        return result;
    };
    _getAddonForCurrentWarranty = function (responseData) {
        let result = { needDisplayed: [], canBeSelected: [], locked: [] };

        if (responseData.addons && responseData.addons.length > 0) {
            let dependenciesAddon = responseData.addons.filter(function (item) { return item.dependencies && item.dependencies.includes("BASE") });
            result.needDisplayed = _recursiveGetDependencies(responseData.addons, dependenciesAddon);
            result.canBeSelected = dependenciesAddon;
        }

        return result;
    };
    _getAddonForSpecificWarranty = function (responseData, pn) {
        let result = { needDisplayed: [], canBeSelected: [], locked: [] };

        if (pn) {
            let selectedWarranties = responseData.warranties.filter(function (item) { return item.partNumber == pn });
            if (selectedWarranties && selectedWarranties.length > 0) {
                let selectedWarranty = selectedWarranties[0];

                result.canBeSelected = responseData.addons.filter(function (item) { return item.dependencies && item.dependencies.includes(pn) });
                result.needDisplayed = _recursiveGetDependencies(responseData.addons, result.canBeSelected);
                if (selectedWarranty.bundles && selectedWarranty.bundles.length > 0) {
                    result.locked = responseData.addons.filter(function (item) { return selectedWarranty.bundles.includes(item.partNumber) });
                    result.canBeSelected = result.needDisplayed.filter(function (item) { return !result.locked.includes(item.partNumber) });
                }
            }
        }

        return result;
    };
    _filterArray = function (addons, iseTerm) {
        let tempList = [];

        addons.map(function (m) {
            let addon = tempList.filter(function (f) { return f.warrantyCode == m.warrantyCode });
            if (addon && addon.length > 0) {
                if (iseTerm && addon[0].warrantyCode == "ISE" && iseTerm != addon[0].unitTerm && iseTerm == m.unitTerm) {
                    addon[0].unitTerm = m.unitTerm;
                    addon[0].partNumber = m.partNumber;
                }
                else {
                    if (m.unitTerm > addon[0].unitTerm) {
                        addon[0].unitTerm = m.unitTerm;
                        addon[0].partNumber = m.partNumber;
                    }
                }
            }
            else {
                tempList.push({
                    warrantyCode: m.warrantyCode,
                    unitTerm: m.unitTerm,
                    partNumber: m.partNumber
                });
            }
        });

        return tempList.map(function (m) { return m.partNumber });
    };
    _recursiveGetDependencies = function (addons, dependenciesAddon) {
        let result = [];

        if (addons && addons.length > 0 && dependenciesAddon && dependenciesAddon.length > 0) {
            result = result.concat(dependenciesAddon);
            if (result.length > 0) {
                let needBreak = false;
                while (!needBreak) {
                    let addNumber = 0;

                    result.map(function (r) {
                        let dependencies = addons.filter(function (addon) { return addon.dependencies && addon.dependencies.includes(r.partNumber) });
                        if (dependencies.length > 0) {
                            dependencies.forEach(function (f) {
                                let exists = result.filter(function (item) { return item.partNumber == f.partNumber }).length > 0;
                                if (!exists) {
                                    result.push(f);
                                    addNumber++;
                                }
                            });
                        }
                    });

                    if (addNumber == 0) needBreak = true;
                }
            }
        }

        return result;
    };
    _clearInvalidSelected = function (addons, selected, selectedWarranty) {
        let needBreak = false;

        if (addons && addons.length > 0) {
            while (!needBreak) {
                let needRemoveIds = [];

                selected.map(function (s) {
                    let selectedAddons = addons.filter(function (a) { return a.partNumber == s });
                    if (selectedAddons && selectedAddons.length > 0) {
                        let dependencies = selectedAddons[0].dependencies;
                        if (dependencies && dependencies.length > 0) {
                            let exists = dependencies.includes(selectedWarranty);
                            if (!exists) {
                                dependencies.some(function (dependencyPartNumber) {
                                    exists = selected.filter(function (partNumber) { return partNumber == dependencyPartNumber }).length > 0;
                                    return exists == true;
                                });
                            }

                            if (!exists)
                                needRemoveIds.push(s);
                        }
                    }
                    else
                        needRemoveIds.push(s);
                });

                if (needRemoveIds.length > 0)
                    selected = selected.filter(function (f) { return !needRemoveIds.includes(f) });
                else
                    needBreak = true;
            }
        }

        return selected;
    }
    _distinct = function (arr) {
        arr = arr || [];
        var newArr = [];
        arr.forEach(function (item) {
            if (newArr.indexOf(item) === -1) newArr.push(item);
        });
        return newArr;
    }
})(serviceOption);